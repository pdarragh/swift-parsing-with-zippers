[{
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 9030,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
        "key.annotated_decl" : "<Declaration>fileprivate struct IdentityDict&lt;T&gt;<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.fileprivate",
            "key.length" : 11,
            "key.offset" : 68
          }
        ],
        "key.bodylength" : 206,
        "key.bodyoffset" : 104,
        "key.doc.column" : 20,
        "key.doc.comment" : "A dictionary-like struct that uses `ObjectIdentifier`s as keys.",
        "key.doc.declaration" : "fileprivate struct IdentityDict<T>",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"2\" column=\"20\"><Name>IdentityDict<\/Name><USR>s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV<\/USR><Declaration>fileprivate struct IdentityDict&lt;T&gt;<\/Declaration><CommentParts><Abstract><Para>A dictionary-like struct that uses <codeVoice>ObjectIdentifier<\/codeVoice>s as keys.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 2,
        "key.doc.name" : "IdentityDict",
        "key.doc.type" : "Class",
        "key.doclength" : 68,
        "key.docoffset" : 0,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>IdentityDict<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV1Txmfp\"><decl.generic_type_param.name>T<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;<\/decl.struct>",
        "key.kind" : "source.lang.swift.decl.struct",
        "key.length" : 231,
        "key.name" : "IdentityDict",
        "key.namelength" : 12,
        "key.nameoffset" : 87,
        "key.offset" : 80,
        "key.parsed_declaration" : "fileprivate struct IdentityDict<T>",
        "key.parsed_scope.end" : 9,
        "key.parsed_scope.start" : 2,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>T<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>T<\/decl.generic_type_param.name><\/decl.generic_type_param>",
            "key.kind" : "source.lang.swift.decl.generic_type_param",
            "key.length" : 1,
            "key.name" : "T",
            "key.namelength" : 1,
            "key.nameoffset" : 100,
            "key.offset" : 100,
            "key.parsed_declaration" : "fileprivate struct IdentityDict<T",
            "key.parsed_scope.end" : 2,
            "key.parsed_scope.start" : 2,
            "key.typename" : "T.Type",
            "key.typeusr" : "$sxmD",
            "key.usr" : "s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV1Txmfp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>private var dict: [<Type usr=\"s:SO\">ObjectIdentifier<\/Type> : T]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.private",
                "key.length" : 7,
                "key.offset" : 109
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>private<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>dict<\/decl.name>: <decl.var.type>[<ref.struct usr=\"s:SO\">ObjectIdentifier<\/ref.struct> : T]<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 35,
            "key.name" : "dict",
            "key.namelength" : 4,
            "key.nameoffset" : 121,
            "key.offset" : 117,
            "key.parsed_declaration" : "private var dict = [ObjectIdentifier : T]()",
            "key.parsed_scope.end" : 3,
            "key.parsed_scope.start" : 3,
            "key.setter_accessibility" : "source.lang.swift.accessibility.private",
            "key.typename" : "[ObjectIdentifier : T]",
            "key.typeusr" : "$sSDySOxGD",
            "key.usr" : "s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV4dictSDySOxGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>subscript(key: <Type usr=\"s:s9AnyObjecta\">AnyObject<\/Type>) -&gt; <Type usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV1Txmfp\">T<\/Type>? { get set }<\/Declaration>",
            "key.bodylength" : 115,
            "key.bodyoffset" : 193,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.function.subscript><syntaxtype.keyword>subscript<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.name>key<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:s9AnyObjecta\">AnyObject<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.generic_type_param usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV1Txmfp\">T<\/ref.generic_type_param>?<\/decl.function.returntype> { <syntaxtype.keyword>get<\/syntaxtype.keyword> <syntaxtype.keyword>set<\/syntaxtype.keyword> }<\/decl.function.subscript>",
            "key.kind" : "source.lang.swift.decl.function.subscript",
            "key.length" : 151,
            "key.name" : "subscript(_:)",
            "key.namelength" : 27,
            "key.nameoffset" : 158,
            "key.offset" : 158,
            "key.parsed_declaration" : "subscript(_ key: AnyObject) -> T?",
            "key.parsed_scope.end" : 8,
            "key.parsed_scope.start" : 5,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.substructure" : [

            ],
            "key.typename" : "<T> (AnyObject) -> T?",
            "key.typeusr" : "$syxSgyXlcD",
            "key.usr" : "s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVyxSgyXlcip"
          }
        ],
        "key.typename" : "IdentityDict<T>.Type",
        "key.typeusr" : "$s3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVyxGmD",
        "key.usr" : "s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
        "key.annotated_decl" : "<Declaration>fileprivate protocol SplitableCollection : <Type usr=\"s:Sl\">Collection<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.fileprivate",
            "key.length" : 11,
            "key.offset" : 527
          }
        ],
        "key.bodylength" : 230,
        "key.bodyoffset" : 581,
        "key.doc.column" : 22,
        "key.doc.comment" : "This protocol allows us to use built-in arrays alongside the custom\n`ReferenceArray` using the same code. This could be thrown away if I were\nokay with more code duplication, but I'm extra, so too bad.",
        "key.doc.declaration" : "fileprivate protocol SplitableCollection : Collection",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"14\" column=\"22\"><Name>SplitableCollection<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP<\/USR><Declaration>fileprivate protocol SplitableCollection : Collection<\/Declaration><CommentParts><Abstract><Para>This protocol allows us to use built-in arrays alongside the custom <codeVoice>ReferenceArray<\/codeVoice> using the same code. This could be thrown away if I were okay with more code duplication, but I’m extra, so too bad.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 14,
        "key.doc.name" : "SplitableCollection",
        "key.doc.type" : "Class",
        "key.doclength" : 214,
        "key.docoffset" : 313,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 10,
            "key.offset" : 569
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>SplitableCollection<\/decl.name> : <ref.protocol usr=\"s:Sl\">Collection<\/ref.protocol><\/decl.protocol>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Collection"
          }
        ],
        "key.kind" : "source.lang.swift.decl.protocol",
        "key.length" : 273,
        "key.name" : "SplitableCollection",
        "key.namelength" : 19,
        "key.nameoffset" : 548,
        "key.offset" : 539,
        "key.parsed_declaration" : "fileprivate protocol SplitableCollection: Collection",
        "key.parsed_scope.end" : 19,
        "key.parsed_scope.start" : 14,
        "key.runtime_name" : "_TtP4mainP33_C52271341CEF4A9281C9B49AC640910719SplitableCollection_",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>var first: <Type usr=\"s:Sl7ElementQa\">Element<\/Type>? { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 686,
            "key.doc.column" : 9,
            "key.doc.comment" : "Get the first element of a collection, if the collection is not empty.",
            "key.doc.declaration" : "var first: Element? { get }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"16\" column=\"9\"><Name>first<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP5first7ElementQzSgvp<\/USR><Declaration>var first: Element? { get }<\/Declaration><CommentParts><Abstract><Para>Get the first element of a collection, if the collection is not empty.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 16,
            "key.doc.name" : "first",
            "key.doc.type" : "Other",
            "key.doclength" : 75,
            "key.docoffset" : 586,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>first<\/decl.name>: <decl.var.type><ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype>?<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 27,
            "key.name" : "first",
            "key.namelength" : 5,
            "key.nameoffset" : 669,
            "key.offset" : 665,
            "key.parsed_declaration" : "var first: Element?",
            "key.parsed_scope.end" : 16,
            "key.parsed_scope.start" : 16,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SlsE5first7ElementQzSgvp\">first<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:STsE5first5where7ElementQzSgSbADKXE_tKF\">first(where:)<\/RelatedName>"
              }
            ],
            "key.typename" : "Self.Element?",
            "key.typeusr" : "$s7ElementSTQzSgD",
            "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP5first7ElementQzSgvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>var rest: <Type usr=\"s:s10ArraySliceV\">ArraySlice<\/Type>&lt;<Type usr=\"s:Sl7ElementQa\">Element<\/Type>&gt; { get }<\/Declaration>",
            "key.bodylength" : 5,
            "key.bodyoffset" : 804,
            "key.doc.column" : 9,
            "key.doc.comment" : "Get a slice of the collection containing all but the first element.",
            "key.doc.declaration" : "var rest: ArraySlice<Element> { get }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"18\" column=\"9\"><Name>rest<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp<\/USR><Declaration>var rest: ArraySlice&lt;Element&gt; { get }<\/Declaration><CommentParts><Abstract><Para>Get a slice of the collection containing all but the first element.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 18,
            "key.doc.name" : "rest",
            "key.doc.type" : "Other",
            "key.doclength" : 72,
            "key.docoffset" : 697,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>rest<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s10ArraySliceV\">ArraySlice<\/ref.struct>&lt;<ref.associatedtype usr=\"s:Sl7ElementQa\">Element<\/ref.associatedtype>&gt;<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 37,
            "key.name" : "rest",
            "key.namelength" : 4,
            "key.nameoffset" : 777,
            "key.offset" : 773,
            "key.parsed_declaration" : "var rest: ArraySlice<Element>",
            "key.parsed_scope.end" : 18,
            "key.parsed_scope.start" : 18,
            "key.typename" : "ArraySlice<Self.Element>",
            "key.typeusr" : "$ss10ArraySliceVy7ElementSTQzGD",
            "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp"
          }
        ],
        "key.typename" : "SplitableCollection.Protocol",
        "key.typeusr" : "$s3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LL_pmD",
        "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>@frozen struct Array&lt;Element&gt; : <Type usr=\"s:s24_DestructorSafeContainerP\">_DestructorSafeContainer<\/Type><\/Declaration>",
        "key.bodylength" : 50,
        "key.bodyoffset" : 898,
        "key.doc.comment" : "Give built-in arrays the `rest` property.",
        "key.doc.declaration" : "struct Array<Element>",
        "key.doc.discussion" : [
          {
            "Para" : "Arrays are one of the most commonly used data types in an app. You use arrays to organize your app’s data. Specifically, you use the `Array` type to hold elements of a single type, the array’s `Element` type. An array can store any kind of elements—from integers to strings to classes."
          },
          {
            "Para" : "Swift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets. Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s `Element` type. For example:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can create an empty array by specifying the `Element` type of your array in the declaration. For example:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you need an array that is preinitialized with a fixed number of default values, use the `Array(repeating:count:)` initializer."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "When you need to perform an operation on all of an array’s elements, use a `for`-`in` loop to iterate through the array’s contents."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Use the `isEmpty` property to check quickly whether an array has any elements, or use the `count` property to find the number of elements in the array."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Use the `first` and `last` properties for safe access to the value of the array’s first and last elements. If the array is empty, these properties are `nil`."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can access individual array elements through a subscript. The first element of a nonempty array is always at index zero. You can subscript an array with any integer from zero up to, but not including, the count of the array. Using a negative number or an index equal to or greater than `count` triggers a runtime error. For example:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Suppose you need to store a list of the names of students that are signed up for a class you’re teaching. During the registration period, you need to add and remove names as students add and drop the class."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "To add single elements to the end of an array, use the `append(_:)` method. Add multiple elements at the same time by passing another array or a sequence of any kind to the `append(contentsOf:)` method."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can add new elements in the middle of an array by using the `insert(_:at:)` method for single elements and by using `insert(contentsOf:at:)` to insert multiple elements from another collection or array literal. The elements at that index and later indices are shifted back to make room."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "To remove elements from an array, use the `remove(at:)`, `removeSubrange(_:)`, and `removeLast()` methods."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can replace an existing element with a new value by assigning the new value to the subscript."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Every array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger."
          },
          {
            "Para" : "If you know approximately how many elements you will need to store, use the `reserveCapacity(_:)` method before appending to the array to avoid intermediate reallocations. Use the `capacity` and `count` properties to determine how many more elements the array can store without allocating larger storage."
          },
          {
            "Para" : "For arrays of most `Element` types, this storage is a contiguous block of memory. For arrays with an `Element` type that is a class or `@objc` protocol type, this storage can be a contiguous block of memory or an instance of `NSArray`. Because any arbitrary subclass of `NSArray` can become an `Array`, there are no guarantees about representation or efficiency in this case."
          },
          {
            "Para" : "Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array. For example:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. For example:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Arrays, like all variable-size collections in the standard library, use copy-on-write optimization. Multiple copies of an array share the same storage until you modify one of the copies. When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place. Optimizations are sometimes applied that can reduce the amount of copying."
          },
          {
            "Para" : "This means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array. An array that is the sole owner of its storage can perform mutating operations in place."
          },
          {
            "Para" : "In the example below, a `numbers` array is created along with two copies that share the same storage. When the original `numbers` array is modified, it makes a unique copy of its storage before making the modification. Further modifications to `numbers` are made in place, while the two copies continue to share the original storage."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "When you need to access APIs that require data in an `NSArray` instance instead of `Array`, use the type-cast operator (`as`) to bridge your instance. For bridging to be possible, the `Element` type of your array must be a class, an `@objc` protocol (a protocol imported from Objective-C or marked with the `@objc` attribute), or a type that bridges to a Foundation type."
          },
          {
            "Para" : "The following example shows how you can bridge an `Array` instance to `NSArray` to use the `write(to:atomically:)` method. In this example, the `colors` array can be bridged to `NSArray` because the `colors` array’s `String` elements bridge to `NSString`. The compiler prevents bridging the `moreColors` array, on the other hand, because its `Element` type is `Optional<String>`, which does  bridge to a Foundation type."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Bridging from `Array` to `NSArray` takes O(1) time and O(1) space if the array’s elements are already instances of a class or an `@objc` protocol; otherwise, it takes O() time and space."
          },
          {
            "Para" : "When the destination array’s element type is a class or an `@objc` protocol, bridging from `NSArray` to `Array` first calls the `copy(with:)` (`- copyWithZone:` in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of `NSArray` that are already immutable, `copy(with:)` usually returns the same array in O(1) time; otherwise, the copying performance is unspecified. If `copy(with:)` returns the same array, the instances of `NSArray` and `Array` share storage using the same copy-on-write optimization that is used when two instances of `Array` share storage."
          },
          {
            "Para" : "When the destination array’s element type is a nonclass type that bridges to a Foundation type, bridging from `NSArray` to `Array` performs a bridging copy of the elements to contiguous storage in O() time. For example, bridging from `NSArray` to `Array<Int>` performs such a copy. No further bridging is required when accessing elements of the `Array` instance."
          },
          {
            "Note" : ""
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Array<\/Name><USR>s:Sa<\/USR><Declaration>struct Array&lt;Element&gt;<\/Declaration><CommentParts><Abstract><Para>An ordered, random-access collection.<\/Para><\/Abstract><Discussion><Para>Arrays are one of the most commonly used data types in an app. You use arrays to organize your app’s data. Specifically, you use the <codeVoice>Array<\/codeVoice> type to hold elements of a single type, the array’s <codeVoice>Element<\/codeVoice> type. An array can store any kind of elements—from integers to strings to classes.<\/Para><Para>Swift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets. Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s <codeVoice>Element<\/codeVoice> type. For example:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ An array of 'Int' elements]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ An array of 'String' elements]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let streets = [\"Albemarle\", \"Brandywine\", \"Chesapeake\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can create an empty array by specifying the <codeVoice>Element<\/codeVoice> type of your array in the declaration. For example:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ Shortened forms are preferred]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var emptyDoubles: [Double] = []]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ The full type name is also allowed]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var emptyFloats: Array<Float> = Array()]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>If you need an array that is preinitialized with a fixed number of default values, use the <codeVoice>Array(repeating:count:)<\/codeVoice> initializer.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var digitCounts = Array(repeating: 0, count: 10)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(digitCounts)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Array Values<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>When you need to perform an operation on all of an array’s elements, use a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop to iterate through the array’s contents.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[for street in streets {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"I don't live on \\(street).\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"I don't live on Albemarle.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"I don't live on Brandywine.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"I don't live on Chesapeake.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Use the <codeVoice>isEmpty<\/codeVoice> property to check quickly whether an array has any elements, or use the <codeVoice>count<\/codeVoice> property to find the number of elements in the array.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if oddNumbers.isEmpty {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"I don't know any odd numbers.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"I know \\(oddNumbers.count) odd numbers.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"I know 8 odd numbers.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Use the <codeVoice>first<\/codeVoice> and <codeVoice>last<\/codeVoice> properties for safe access to the value of the array’s first and last elements. If the array is empty, these properties are <codeVoice>nil<\/codeVoice>.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(firstElement, lastElement, separator: \", \")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1, 15\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(emptyDoubles.first, emptyDoubles.last, separator: \", \")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"nil, nil\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can access individual array elements through a subscript. The first element of a nonempty array is always at index zero. You can subscript an array with any integer from zero up to, but not including, the count of the array. Using a negative number or an index equal to or greater than <codeVoice>count<\/codeVoice> triggers a runtime error. For example:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(oddNumbers[0], oddNumbers[3], separator: \", \")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"1, 7\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(emptyDoubles[0])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Triggers runtime error: Index out of range]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Adding and Removing Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Suppose you need to store a list of the names of students that are signed up for a class you’re teaching. During the registration period, you need to add and remove names as students add and drop the class.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var students = [\"Ben\", \"Ivy\", \"Jordell\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>To add single elements to the end of an array, use the <codeVoice>append(_:)<\/codeVoice> method. Add multiple elements at the same time by passing another array or a sequence of any kind to the <codeVoice>append(contentsOf:)<\/codeVoice> method.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[students.append(\"Maxime\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[students.append(contentsOf: [\"Shakia\", \"William\"])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\", \"Shakia\", \"William\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can add new elements in the middle of an array by using the <codeVoice>insert(_:at:)<\/codeVoice> method for single elements and by using <codeVoice>insert(contentsOf:at:)<\/codeVoice> to insert multiple elements from another collection or array literal. The elements at that index and later indices are shifted back to make room.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[students.insert(\"Liam\", at: 3)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ [\"Ben\", \"Ivy\", \"Jordell\", \"Liam\", \"Maxime\", \"Shakia\", \"William\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>To remove elements from an array, use the <codeVoice>remove(at:)<\/codeVoice>, <codeVoice>removeSubrange(_:)<\/codeVoice>, and <codeVoice>removeLast()<\/codeVoice> methods.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ Ben's family is moving to another state]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[students.remove(at: 0)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ [\"Ivy\", \"Jordell\", \"Liam\", \"Maxime\", \"Shakia\", \"William\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ William is signing up for a different class]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[students.removeLast()]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ [\"Ivy\", \"Jordell\", \"Liam\", \"Maxime\", \"Shakia\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can replace an existing element with a new value by assigning the new value to the subscript.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let i = students.firstIndex(of: \"Maxime\") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    students[i] = \"Max\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ [\"Ivy\", \"Jordell\", \"Liam\", \"Max\", \"Shakia\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Growing the Size of an Array<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>Every array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.<\/Para><Para>If you know approximately how many elements you will need to store, use the <codeVoice>reserveCapacity(_:)<\/codeVoice> method before appending to the array to avoid intermediate reallocations. Use the <codeVoice>capacity<\/codeVoice> and <codeVoice>count<\/codeVoice> properties to determine how many more elements the array can store without allocating larger storage.<\/Para><Para>For arrays of most <codeVoice>Element<\/codeVoice> types, this storage is a contiguous block of memory. For arrays with an <codeVoice>Element<\/codeVoice> type that is a class or <codeVoice>@objc<\/codeVoice> protocol type, this storage can be a contiguous block of memory or an instance of <codeVoice>NSArray<\/codeVoice>. Because any arbitrary subclass of <codeVoice>NSArray<\/codeVoice> can become an <codeVoice>Array<\/codeVoice>, there are no guarantees about representation or efficiency in this case.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Modifying Copies of Arrays<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array. For example:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var numbers = [1, 2, 3, 4, 5]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var numbersCopy = numbers]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[numbers[0] = 100]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(numbers)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[100, 2, 3, 4, 5]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(numbersCopy)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[1, 2, 3, 4, 5]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. For example:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[\/\/ An integer type with reference semantics]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[class IntegerReference {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    var value = 10]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var firstIntegers = [IntegerReference(), IntegerReference()]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var secondIntegers = firstIntegers]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Modifications to an instance are visible from either array]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[firstIntegers[0].value = 100]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondIntegers[0].value)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"100\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Replacements, additions, and removals are still visible]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ only in the modified array]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[firstIntegers[0] = IntegerReference()]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstIntegers[0].value)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"10\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondIntegers[0].value)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"100\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Arrays, like all variable-size collections in the standard library, use copy-on-write optimization. Multiple copies of an array share the same storage until you modify one of the copies. When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place. Optimizations are sometimes applied that can reduce the amount of copying.<\/Para><Para>This means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array. An array that is the sole owner of its storage can perform mutating operations in place.<\/Para><Para>In the example below, a <codeVoice>numbers<\/codeVoice> array is created along with two copies that share the same storage. When the original <codeVoice>numbers<\/codeVoice> array is modified, it makes a unique copy of its storage before making the modification. Further modifications to <codeVoice>numbers<\/codeVoice> are made in place, while the two copies continue to share the original storage.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var numbers = [1, 2, 3, 4, 5]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var firstCopy = numbers]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[var secondCopy = numbers]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ The storage for 'numbers' is copied here]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[numbers[0] = 100]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[numbers[1] = 200]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[numbers[2] = 300]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'numbers' is [100, 200, 300, 4, 5]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between Array and NSArray<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>When you need to access APIs that require data in an <codeVoice>NSArray<\/codeVoice> instance instead of <codeVoice>Array<\/codeVoice>, use the type-cast operator (<codeVoice>as<\/codeVoice>) to bridge your instance. For bridging to be possible, the <codeVoice>Element<\/codeVoice> type of your array must be a class, an <codeVoice>@objc<\/codeVoice> protocol (a protocol imported from Objective-C or marked with the <codeVoice>@objc<\/codeVoice> attribute), or a type that bridges to a Foundation type.<\/Para><Para>The following example shows how you can bridge an <codeVoice>Array<\/codeVoice> instance to <codeVoice>NSArray<\/codeVoice> to use the <codeVoice>write(to:atomically:)<\/codeVoice> method. In this example, the <codeVoice>colors<\/codeVoice> array can be bridged to <codeVoice>NSArray<\/codeVoice> because the <codeVoice>colors<\/codeVoice> array’s <codeVoice>String<\/codeVoice> elements bridge to <codeVoice>NSString<\/codeVoice>. The compiler prevents bridging the <codeVoice>moreColors<\/codeVoice> array, on the other hand, because its <codeVoice>Element<\/codeVoice> type is <codeVoice>Optional&lt;String&gt;<\/codeVoice>, which does <emphasis>not<\/emphasis> bridge to a Foundation type.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let colors = [\"periwinkle\", \"rose\", \"moss\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let moreColors: [String?] = [\"ochre\", \"pine\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let url = NSURL(fileURLWithPath: \"names.plist\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[(colors as NSArray).write(to: url, atomically: true)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ true]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[(moreColors as NSArray).write(to: url, atomically: true)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ error: cannot convert value of type '[String?]' to type 'NSArray']]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Bridging from <codeVoice>Array<\/codeVoice> to <codeVoice>NSArray<\/codeVoice> takes O(1) time and O(1) space if the array’s elements are already instances of a class or an <codeVoice>@objc<\/codeVoice> protocol; otherwise, it takes O(<emphasis>n<\/emphasis>) time and space.<\/Para><Para>When the destination array’s element type is a class or an <codeVoice>@objc<\/codeVoice> protocol, bridging from <codeVoice>NSArray<\/codeVoice> to <codeVoice>Array<\/codeVoice> first calls the <codeVoice>copy(with:)<\/codeVoice> (<codeVoice>- copyWithZone:<\/codeVoice> in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <codeVoice>NSArray<\/codeVoice> that are already immutable, <codeVoice>copy(with:)<\/codeVoice> usually returns the same array in O(1) time; otherwise, the copying performance is unspecified. If <codeVoice>copy(with:)<\/codeVoice> returns the same array, the instances of <codeVoice>NSArray<\/codeVoice> and <codeVoice>Array<\/codeVoice> share storage using the same copy-on-write optimization that is used when two instances of <codeVoice>Array<\/codeVoice> share storage.<\/Para><Para>When the destination array’s element type is a nonclass type that bridges to a Foundation type, bridging from <codeVoice>NSArray<\/codeVoice> to <codeVoice>Array<\/codeVoice> performs a bridging copy of the elements to contiguous storage in O(<emphasis>n<\/emphasis>) time. For example, bridging from <codeVoice>NSArray<\/codeVoice> to <codeVoice>Array&lt;Int&gt;<\/codeVoice> performs such a copy. No further bridging is required when accessing elements of the <codeVoice>Array<\/codeVoice> instance.<\/Para><Note><Para>The <codeVoice>ContiguousArray<\/codeVoice> and <codeVoice>ArraySlice<\/codeVoice> types are not bridged; instances of those types always have a contiguous block of memory as their storage.<\/Para><\/Note><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Array",
        "key.doc.type" : "Class",
        "key.doclength" : 46,
        "key.docoffset" : 814,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 19,
            "key.offset" : 877
          }
        ],
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.attribute.builtin><syntaxtype.attribute.name>@frozen<\/syntaxtype.attribute.name><\/syntaxtype.attribute.builtin> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Array<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sa7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s24_DestructorSafeContainerP\">_DestructorSafeContainer<\/ref.protocol><\/decl.struct>",
        "key.groupname" : "Collection\/Array",
        "key.inheritedtypes" : [
          {
            "key.name" : "SplitableCollection"
          }
        ],
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 89,
        "key.modulename" : "Swift",
        "key.name" : "Array",
        "key.namelength" : 5,
        "key.nameoffset" : 870,
        "key.offset" : 860,
        "key.parsed_declaration" : "extension Array: SplitableCollection",
        "key.parsed_scope.end" : 24,
        "key.parsed_scope.start" : 22,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var rest: <Type usr=\"s:s10ArraySliceV\">ArraySlice<\/Type>&lt;<Type usr=\"s:Sa3PwZE7Elementxmfp\">Element<\/Type>&gt; { get }<\/Declaration>",
            "key.bodylength" : 12,
            "key.bodyoffset" : 934,
            "key.doc.column" : 9,
            "key.doc.declaration" : "var rest: ArraySlice<Element> { get }",
            "key.doc.discussion" : [
              {
                "Note" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"18\" column=\"9\"><Name>rest<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp<\/USR><Declaration>var rest: ArraySlice&lt;Element&gt; { get }<\/Declaration><CommentParts><Abstract><Para>Get a slice of the collection containing all but the first element.<\/Para><\/Abstract><Discussion><Note><Para>This documentation comment was inherited from <codeVoice>SplitableCollection<\/codeVoice>.<\/Para><\/Note><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 18,
            "key.doc.name" : "rest",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>rest<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s10ArraySliceV\">ArraySlice<\/ref.struct>&lt;<ref.generic_type_param usr=\"s:Sa3PwZE7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.groupname" : "Collection\/Array",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 44,
            "key.name" : "rest",
            "key.namelength" : 4,
            "key.nameoffset" : 907,
            "key.offset" : 903,
            "key.overrides" : [
              {
                "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp"
              }
            ],
            "key.parsed_declaration" : "var rest: ArraySlice<Element>",
            "key.parsed_scope.end" : 23,
            "key.parsed_scope.start" : 23,
            "key.typename" : "ArraySlice<Element>",
            "key.typeusr" : "$ss10ArraySliceVyxGD",
            "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp"
          }
        ],
        "key.typename" : "Array<Element>.Type",
        "key.typeusr" : "$sSayxGmD",
        "key.usr" : "s:Sa"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public class ReferenceArray&lt;Element&gt; : <Type usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/Type> where Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.bodylength" : 101,
        "key.bodyoffset" : 1060,
        "key.doc.column" : 14,
        "key.doc.comment" : "Give `ReferenceArray`s the `first` and `rest` properties.",
        "key.doc.declaration" : "public class ReferenceArray<Element> : ExpressibleByArrayLiteral where Element : Equatable",
        "key.doc.discussion" : [
          {
            "Para" : "Only the necessary methods are implemented."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"7\" column=\"14\"><Name>ReferenceArray<\/Name><USR>s:3PwZ14ReferenceArrayC<\/USR><Declaration>public class ReferenceArray&lt;Element&gt; : ExpressibleByArrayLiteral where Element : Equatable<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ReferenceArray<\/codeVoice> is a wrapper around the standard <codeVoice>Array<\/codeVoice> that provides reference semantics for mutable array objects.<\/Para><\/Abstract><Discussion><Para>Only the necessary methods are implemented.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 7,
        "key.doc.name" : "ReferenceArray",
        "key.doc.type" : "Class",
        "key.doclength" : 62,
        "key.docoffset" : 951,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 19,
            "key.offset" : 1039
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ReferenceArray<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "SplitableCollection"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 149,
        "key.name" : "ReferenceArray",
        "key.namelength" : 14,
        "key.nameoffset" : 1023,
        "key.offset" : 1013,
        "key.parsed_declaration" : "extension ReferenceArray: SplitableCollection",
        "key.parsed_scope.end" : 30,
        "key.parsed_scope.start" : 27,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var first: <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>? { get }<\/Declaration>",
            "key.bodylength" : 18,
            "key.bodyoffset" : 1086,
            "key.doc.column" : 9,
            "key.doc.declaration" : "var first: Element? { get }",
            "key.doc.discussion" : [
              {
                "Note" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"16\" column=\"9\"><Name>first<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP5first7ElementQzSgvp<\/USR><Declaration>var first: Element? { get }<\/Declaration><CommentParts><Abstract><Para>Get the first element of a collection, if the collection is not empty.<\/Para><\/Abstract><Discussion><Note><Para>This documentation comment was inherited from <codeVoice>SplitableCollection<\/codeVoice>.<\/Para><\/Note><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 16,
            "key.doc.name" : "first",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>first<\/decl.name>: <decl.var.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>?<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 40,
            "key.name" : "first",
            "key.namelength" : 5,
            "key.nameoffset" : 1069,
            "key.offset" : 1065,
            "key.overrides" : [
              {
                "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP5first7ElementQzSgvp"
              }
            ],
            "key.parsed_declaration" : "var first: Element?",
            "key.parsed_scope.end" : 28,
            "key.parsed_scope.start" : 28,
            "key.typename" : "Element?",
            "key.typeusr" : "$sxSgD",
            "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP5first7ElementQzSgvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var rest: <Type usr=\"s:s10ArraySliceV\">ArraySlice<\/Type>&lt;<Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>&gt; { get }<\/Declaration>",
            "key.bodylength" : 18,
            "key.bodyoffset" : 1141,
            "key.doc.column" : 9,
            "key.doc.declaration" : "var rest: ArraySlice<Element> { get }",
            "key.doc.discussion" : [
              {
                "Note" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"18\" column=\"9\"><Name>rest<\/Name><USR>s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp<\/USR><Declaration>var rest: ArraySlice&lt;Element&gt; { get }<\/Declaration><CommentParts><Abstract><Para>Get a slice of the collection containing all but the first element.<\/Para><\/Abstract><Discussion><Note><Para>This documentation comment was inherited from <codeVoice>SplitableCollection<\/codeVoice>.<\/Para><\/Note><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 18,
            "key.doc.name" : "rest",
            "key.doc.type" : "Other",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>rest<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s10ArraySliceV\">ArraySlice<\/ref.struct>&lt;<ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 50,
            "key.name" : "rest",
            "key.namelength" : 4,
            "key.nameoffset" : 1114,
            "key.offset" : 1110,
            "key.overrides" : [
              {
                "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp"
              }
            ],
            "key.parsed_declaration" : "var rest: ArraySlice<Element>",
            "key.parsed_scope.end" : 29,
            "key.parsed_scope.start" : 29,
            "key.typename" : "ArraySlice<Element>",
            "key.typeusr" : "$ss10ArraySliceVyxGD",
            "key.usr" : "s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP4rests10ArraySliceVy7ElementQzGvp"
          }
        ],
        "key.typename" : "ReferenceArray<Element>.Type",
        "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGmD",
        "key.usr" : "s:3PwZ14ReferenceArrayC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>func render(expression root: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; <Type usr=\"s:SS\">String<\/Type><\/Declaration>",
        "key.bodylength" : 7203,
        "key.bodyoffset" : 1825,
        "key.doc.column" : 6,
        "key.doc.comment" : "Renders an `Expression` to a string ready for printing. Recursive references to\nexpressions will be abbreviated and the referred-to expressions annotated with\nthe abbreviation for reference.\n\nNOTE: This function will not follow recursive references, but it still iterates\n      over the entire grammar structure a few times to produce a pretty output.\n      It is recommended that the function is not run often if performance is a\n      concern.\n\n- Parameters:\n    - expression: The root expression of a grammar to render for printing.\n- Returns: A string representing the given expression.",
        "key.doc.declaration" : "func render(expression root: Expression) -> String",
        "key.doc.discussion" : [
          {
            "Para" : "NOTE: This function will not follow recursive references, but it still iterates over the entire grammar structure a few times to produce a pretty output. It is recommended that the function is not run often if performance is a concern."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"46\" column=\"6\"><Name>render(expression:)<\/Name><USR>s:3PwZ6render10expressionSSAA10ExpressionC_tF<\/USR><Declaration>func render(expression root: Expression) -&gt; String<\/Declaration><CommentParts><Abstract><Para>Renders an <codeVoice>Expression<\/codeVoice> to a string ready for printing. Recursive references to expressions will be abbreviated and the referred-to expressions annotated with the abbreviation for reference.<\/Para><\/Abstract><Parameters><Parameter><Name>expression<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The root expression of a grammar to render for printing.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>A string representing the given expression.<\/Para><\/ResultDiscussion><Discussion><Para>NOTE: This function will not follow recursive references, but it still iterates over the entire grammar structure a few times to produce a pretty output. It is recommended that the function is not run often if performance is a concern.<\/Para><\/Discussion><\/CommentParts><\/Function>",
        "key.doc.line" : 46,
        "key.doc.name" : "render(expression:)",
        "key.doc.parameters" : [
          {
            "discussion" : [
              {
                "Para" : "The root expression of a grammar to render for printing."
              }
            ],
            "name" : "expression"
          }
        ],
        "key.doc.result_discussion" : [
          {
            "Para" : "A string representing the given expression."
          }
        ],
        "key.doc.type" : "Function",
        "key.doclength" : 608,
        "key.docoffset" : 1164,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>render<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>expression<\/decl.var.parameter.argument_label> <decl.var.parameter.name>root<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.function.returntype><\/decl.function.free>",
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.length" : 7256,
        "key.name" : "render(expression:)",
        "key.namelength" : 35,
        "key.nameoffset" : 1778,
        "key.offset" : 1773,
        "key.parsed_declaration" : "func render(expression root: Expression) -> String",
        "key.parsed_scope.end" : 193,
        "key.parsed_scope.start" : 46,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>var expressionNumbers: <Type usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV\">IdentityDict<\/Type>&lt;<Type usr=\"s:Si\">Int<\/Type>&gt;<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>expressionNumbers<\/decl.name>: <decl.var.type><ref.struct usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV\">IdentityDict<\/ref.struct>&lt;<ref.struct usr=\"s:Si\">Int<\/ref.struct>&gt;<\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 43,
            "key.name" : "expressionNumbers",
            "key.namelength" : 17,
            "key.nameoffset" : 1905,
            "key.offset" : 1901,
            "key.parsed_declaration" : "var expressionNumbers = IdentityDict<Int>()",
            "key.parsed_scope.end" : 48,
            "key.parsed_scope.start" : 48,
            "key.typename" : "IdentityDict<Int>",
            "key.typeusr" : "$s3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVySiGD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF0C7NumbersL_AA12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVySiGvp"
          },
          {
            "key.annotated_decl" : "<Declaration>var nextExpressionNumber: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>nextExpressionNumber<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 28,
            "key.name" : "nextExpressionNumber",
            "key.namelength" : 20,
            "key.nameoffset" : 1953,
            "key.offset" : 1949,
            "key.parsed_declaration" : "var nextExpressionNumber = 0",
            "key.parsed_scope.end" : 49,
            "key.parsed_scope.start" : 49,
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF04nextD6NumberL_Sivp"
          },
          {
            "key.annotated_decl" : "<Declaration>var depthPrintMap: [<Type usr=\"s:Si\">Int<\/Type> : <Type usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV\">IdentityDict<\/Type>&lt;<Type usr=\"s:Sb\">Bool<\/Type>&gt;]<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>depthPrintMap<\/decl.name>: <decl.var.type>[<ref.struct usr=\"s:Si\">Int<\/ref.struct> : <ref.struct usr=\"s:3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLV\">IdentityDict<\/ref.struct>&lt;<ref.struct usr=\"s:Sb\">Bool<\/ref.struct>&gt;]<\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 48,
            "key.name" : "depthPrintMap",
            "key.namelength" : 13,
            "key.nameoffset" : 2129,
            "key.offset" : 2125,
            "key.parsed_declaration" : "var depthPrintMap = [Int : IdentityDict<Bool>]()",
            "key.parsed_scope.end" : 52,
            "key.parsed_scope.start" : 52,
            "key.typename" : "[Int : IdentityDict<Bool>]",
            "key.typeusr" : "$sSDySi3PwZ12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVySbGGD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF13depthPrintMapL_SDySiAA12IdentityDict33_BE0BEA97E421695BB8887C1A8AA5F056LLVySbGGvp"
          },
          {
            "key.annotated_decl" : "<Declaration>var queue: [(<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>, <Type usr=\"s:Si\">Int<\/Type>)]<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>queue<\/decl.name>: <decl.var.type>[<tuple>(<tuple.element><tuple.element.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/tuple.element.type><\/tuple.element>)<\/tuple>]<\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 23,
            "key.name" : "queue",
            "key.namelength" : 5,
            "key.nameoffset" : 2339,
            "key.offset" : 2335,
            "key.parsed_declaration" : "var queue = [(root, 0)]",
            "key.parsed_scope.end" : 56,
            "key.parsed_scope.start" : 56,
            "key.typename" : "[(Expression, Int)]",
            "key.typeusr" : "$sSay3PwZ10ExpressionC_SitGD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF5queueL_SayAE_SitGvp"
          },
          {
            "key.annotated_decl" : "<Declaration>var texts: [<Type usr=\"s:SS\">String<\/Type>]<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>texts<\/decl.name>: <decl.var.type>[<ref.struct usr=\"s:SS\">String<\/ref.struct>]<\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 22,
            "key.name" : "texts",
            "key.namelength" : 5,
            "key.nameoffset" : 4667,
            "key.offset" : 4663,
            "key.parsed_declaration" : "var texts = [String]()",
            "key.parsed_scope.end" : 102,
            "key.parsed_scope.start" : 102,
            "key.typename" : "[String]",
            "key.typeusr" : "$sSaySSGD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF5textsL_SaySSGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>func render&lt;T&gt;(childExpressions: <Type usr=\"s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF1TL_xmfp\">T<\/Type>, ofExpressionNumber number: <Type usr=\"s:Si\">Int<\/Type>, atDepth depth: <Type usr=\"s:Si\">Int<\/Type>, withIndentation indentation: <Type usr=\"s:Si\">Int<\/Type>, withStartingText startingText: <Type usr=\"s:SS\">String<\/Type>) where T : <Type usr=\"s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP\">SplitableCollection<\/Type>, T.Element == <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
            "key.bodylength" : 1491,
            "key.bodyoffset" : 5553,
            "key.doc.column" : 10,
            "key.doc.comment" : "Renders a collection of child `Expression`s, adding output text to the\n`texts` array.\n\n- Parameters:\n    - childExpressions: The collection of child expressions to render.\n    - number: The reference number of the parent expression.\n    - depth: The children's tree depth, used for rendering the children.\n    - indentation: The leading indentation of the parent expression.\n    - startingText: Text used for rendering the parent.",
            "key.doc.declaration" : "func render<T>(childExpressions: T, ofExpressionNumber number: Int, atDepth depth: Int, withIndentation indentation: Int, withStartingText startingText: String) where T : PwZ.SplitableCollection, T.Element == PwZ.Expression",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"115\" column=\"10\"><Name>render(childExpressions:ofExpressionNumber:atDepth:withIndentation:withStartingText:)<\/Name><USR>s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF<\/USR><Declaration>func render&lt;T&gt;(childExpressions: T, ofExpressionNumber number: Int, atDepth depth: Int, withIndentation indentation: Int, withStartingText startingText: String) where T : PwZ.SplitableCollection, T.Element == PwZ.Expression<\/Declaration><CommentParts><Abstract><Para>Renders a collection of child <codeVoice>Expression<\/codeVoice>s, adding output text to the <codeVoice>texts<\/codeVoice> array.<\/Para><\/Abstract><Parameters><Parameter><Name>childExpressions<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The collection of child expressions to render.<\/Para><\/Discussion><\/Parameter><Parameter><Name>number<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The reference number of the parent expression.<\/Para><\/Discussion><\/Parameter><Parameter><Name>depth<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The children’s tree depth, used for rendering the children.<\/Para><\/Discussion><\/Parameter><Parameter><Name>indentation<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The leading indentation of the parent expression.<\/Para><\/Discussion><\/Parameter><Parameter><Name>startingText<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>Text used for rendering the parent.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 115,
            "key.doc.name" : "render(childExpressions:ofExpressionNumber:atDepth:withIndentation:withStartingText:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The collection of child expressions to render."
                  }
                ],
                "name" : "childExpressions"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The reference number of the parent expression."
                  }
                ],
                "name" : "number"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The children’s tree depth, used for rendering the children."
                  }
                ],
                "name" : "depth"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The leading indentation of the parent expression."
                  }
                ],
                "name" : "indentation"
              },
              {
                "discussion" : [
                  {
                    "Para" : "Text used for rendering the parent."
                  }
                ],
                "name" : "startingText"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 482,
            "key.docoffset" : 4691,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>render<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF1TL_xmfp\"><decl.generic_type_param.name>T<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>childExpressions<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF1TL_xmfp\">T<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>ofExpressionNumber<\/decl.var.parameter.argument_label> <decl.var.parameter.name>number<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>atDepth<\/decl.var.parameter.argument_label> <decl.var.parameter.name>depth<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withIndentation<\/decl.var.parameter.argument_label> <decl.var.parameter.name>indentation<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withStartingText<\/decl.var.parameter.argument_label> <decl.var.parameter.name>startingText<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>T : <ref.protocol usr=\"s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP\">SplitableCollection<\/ref.protocol><\/decl.generic_type_requirement>, <decl.generic_type_requirement>T.Element == <ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.generic_type_requirement><\/decl.function.free>",
            "key.kind" : "source.lang.swift.decl.function.free",
            "key.length" : 1867,
            "key.name" : "render(childExpressions:ofExpressionNumber:atDepth:withIndentation:withStartingText:)",
            "key.namelength" : 332,
            "key.nameoffset" : 5183,
            "key.offset" : 5178,
            "key.parsed_declaration" : "func render<T: SplitableCollection>(childExpressions: T,\n                                   ofExpressionNumber number: Int,\n                                   atDepth depth: Int,\n                                   withIndentation indentation: Int,\n                                   withStartingText startingText: String)\n  where T.Element == Expression",
            "key.parsed_scope.end" : 147,
            "key.parsed_scope.start" : 115,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ6render10expressionSSAA10ExpressionC_tF\">render(expression:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>T : <Type usr=\"s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP\">SplitableCollection<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 19,
                    "key.offset" : 5193
                  }
                ],
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>T<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLP\">SplitableCollection<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "SplitableCollection"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 22,
                "key.name" : "T",
                "key.namelength" : 1,
                "key.nameoffset" : 5190,
                "key.offset" : 5190,
                "key.parsed_declaration" : "func render<T: SplitableCollection",
                "key.parsed_scope.end" : 115,
                "key.parsed_scope.start" : 115,
                "key.typename" : "T.Type",
                "key.typeusr" : "$sxmD",
                "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF1TL_xmfp"
              },
              {
                "key.annotated_decl" : "<Declaration>let startingIndentation: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>startingIndentation<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 58,
                "key.name" : "startingIndentation",
                "key.namelength" : 19,
                "key.nameoffset" : 5712,
                "key.offset" : 5708,
                "key.parsed_declaration" : "let startingIndentation = indentation + startingText.count",
                "key.parsed_scope.end" : 123,
                "key.parsed_scope.start" : 123,
                "key.typename" : "Int",
                "key.typeusr" : "$sSiD",
                "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF08startingL0L_Sivp"
              }
            ],
            "key.typename" : "<T where T : SplitableCollection, T.Element == Expression> (childExpressions: T, ofExpressionNumber: Int, atDepth: Int, withIndentation: Int, withStartingText: String) -> ()",
            "key.typeusr" : "$s16childExpressions18ofExpressionNumber7atDepth15withIndentation0H12StartingTextyx_S3iSStc3PwZ19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAF0D0C7ElementRtzluD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tFABL_16childExpressions02ofD6Number7atDepth15withIndentation0K12StartingTextyx_S3iSStAA19SplitableCollection33_BE0BEA97E421695BB8887C1A8AA5F056LLRzAE7ElementRtzlF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>func render(expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>, withIndentation indentation: <Type usr=\"s:Si\">Int<\/Type>, atDepth depth: <Type usr=\"s:Si\">Int<\/Type>)<\/Declaration>",
            "key.bodylength" : 1369,
            "key.bodyoffset" : 7416,
            "key.doc.column" : 10,
            "key.doc.comment" : "Renders an `Expression`, adding output text to the `texts` array.\n\n- Parameters\n    - expression: The expression to render.\n    - indentation: The leading indentation of the expression.\n    - depth: The tree depth of the expression.",
            "key.doc.declaration" : "func render(expression: Expression, withIndentation indentation: Int, atDepth depth: Int)",
            "key.doc.discussion" : [
              {
                "List-Bullet" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift\" line=\"157\" column=\"10\"><Name>render(expression:withIndentation:atDepth:)<\/Name><USR>s:3PwZ6render10expressionSSAA10ExpressionC_tFABL0_AC15withIndentation7atDepthyAE_S2itF<\/USR><Declaration>func render(expression: Expression, withIndentation indentation: Int, atDepth depth: Int)<\/Declaration><CommentParts><Abstract><Para>Renders an <codeVoice>Expression<\/codeVoice>, adding output text to the <codeVoice>texts<\/codeVoice> array.<\/Para><\/Abstract><Discussion><List-Bullet><Item><Para>Parameters<\/Para><List-Bullet><Item><Para>expression: The expression to render.<\/Para><\/Item><Item><Para>indentation: The leading indentation of the expression.<\/Para><\/Item><Item><Para>depth: The tree depth of the expression.<\/Para><\/Item><\/List-Bullet><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Function>",
            "key.doc.line" : 157,
            "key.doc.name" : "render(expression:withIndentation:atDepth:)",
            "key.doc.type" : "Function",
            "key.doclength" : 269,
            "key.docoffset" : 7051,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
            "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>render<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>expression<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withIndentation<\/decl.var.parameter.argument_label> <decl.var.parameter.name>indentation<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>atDepth<\/decl.var.parameter.argument_label> <decl.var.parameter.name>depth<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.free>",
            "key.kind" : "source.lang.swift.decl.function.free",
            "key.length" : 1461,
            "key.name" : "render(expression:withIndentation:atDepth:)",
            "key.namelength" : 84,
            "key.nameoffset" : 7330,
            "key.offset" : 7325,
            "key.parsed_declaration" : "func render(expression: Expression, withIndentation indentation: Int, atDepth depth: Int)",
            "key.parsed_scope.end" : 186,
            "key.parsed_scope.start" : 157,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ6render10expressionSSAA10ExpressionC_tF\">render(expression:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let number: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ExpressionPrinting.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>number<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 43,
                "key.name" : "number",
                "key.namelength" : 6,
                "key.nameoffset" : 7492,
                "key.offset" : 7488,
                "key.parsed_declaration" : "let number = expressionNumbers[expression]!",
                "key.parsed_scope.end" : 159,
                "key.parsed_scope.start" : 159,
                "key.typename" : "Int",
                "key.typeusr" : "$sSiD",
                "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tFABL0_AC15withIndentation7atDepthyAE_S2itF6numberL_Sivp"
              }
            ],
            "key.typename" : "(Expression, Int, Int) -> ()",
            "key.typeusr" : "$s10expression15withIndentation7atDepthy3PwZ10ExpressionC_S2itcD",
            "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tFABL0_AC15withIndentation7atDepthyAE_S2itF"
          }
        ],
        "key.typename" : "(Expression) -> String",
        "key.typeusr" : "$s10expressionSS3PwZ10ExpressionC_tcD",
        "key.usr" : "s:3PwZ6render10expressionSSAA10ExpressionC_tF"
      }
    ]
  }
}, {
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 12667,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public enum GrammarError : <Type usr=\"s:s5ErrorP\">Error<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 63
          }
        ],
        "key.bodylength" : 232,
        "key.bodyoffset" : 96,
        "key.doc.column" : 13,
        "key.doc.comment" : "Errors related to the creation of grammars of expressions.",
        "key.doc.declaration" : "public enum GrammarError : Error",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"2\" column=\"13\"><Name>GrammarError<\/Name><USR>s:3PwZ12GrammarErrorO<\/USR><Declaration>public enum GrammarError : Error<\/Declaration><CommentParts><Abstract><Para>Errors related to the creation of grammars of expressions.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 2,
        "key.doc.name" : "GrammarError",
        "key.doc.type" : "Other",
        "key.doclength" : 63,
        "key.docoffset" : 0,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 5,
            "key.offset" : 89
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>GrammarError<\/decl.name> : <ref.protocol usr=\"s:s5ErrorP\">Error<\/ref.protocol><\/decl.enum>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Error"
          }
        ],
        "key.kind" : "source.lang.swift.decl.enum",
        "key.length" : 259,
        "key.name" : "GrammarError",
        "key.namelength" : 12,
        "key.nameoffset" : 75,
        "key.offset" : 70,
        "key.parsed_declaration" : "public enum GrammarError: Error",
        "key.parsed_scope.end" : 8,
        "key.parsed_scope.start" : 2,
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 18,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 162,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case NoStartSymbol<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Thrown when no start symbol is present in a grammar.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"4\" column=\"10\"><Name>NoStartSymbol<\/Name><USR>s:3PwZ12GrammarErrorO13NoStartSymbolyA2CmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Thrown when no start symbol is present in a grammar.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 4,
                "key.doc.name" : "NoStartSymbol",
                "key.doc.type" : "Other",
                "key.doclength" : 57,
                "key.docoffset" : 101,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>NoStartSymbol<\/decl.name><\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 13,
                "key.name" : "NoStartSymbol",
                "key.namelength" : 13,
                "key.nameoffset" : 167,
                "key.offset" : 167,
                "key.parsed_declaration" : "case NoStartSymbol",
                "key.parsed_scope.end" : 4,
                "key.parsed_scope.start" : 4,
                "key.typename" : "(GrammarError.Type) -> GrammarError",
                "key.typeusr" : "$sy3PwZ12GrammarErrorOACmcD",
                "key.usr" : "s:3PwZ12GrammarErrorO13NoStartSymbolyA2CmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 35,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 292,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case NoTagForSymbol(symbol: <Type usr=\"s:SS\">String<\/Type>)<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Thrown when attempting to tokenize a symbol that has no matching token\nin a given grammar.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"7\" column=\"10\"><Name>NoTagForSymbol(symbol:)<\/Name><USR>s:3PwZ12GrammarErrorO14NoTagForSymbolyACSS_tcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Thrown when attempting to tokenize a symbol that has no matching token in a given grammar.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 7,
                "key.doc.name" : "NoTagForSymbol(symbol:)",
                "key.doc.type" : "Other",
                "key.doclength" : 103,
                "key.docoffset" : 185,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>NoTagForSymbol<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>symbol<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 30,
                "key.name" : "NoTagForSymbol(symbol:)",
                "key.namelength" : 30,
                "key.nameoffset" : 297,
                "key.offset" : 297,
                "key.parsed_declaration" : "case NoTagForSymbol(symbol: String)",
                "key.parsed_scope.end" : 7,
                "key.parsed_scope.start" : 7,
                "key.typename" : "(GrammarError.Type) -> (String) -> GrammarError",
                "key.typeusr" : "$sy3PwZ12GrammarErrorOSS_tcACmcD",
                "key.usr" : "s:3PwZ12GrammarErrorO14NoTagForSymbolyACSS_tcACmF"
              }
            ]
          }
        ],
        "key.typename" : "GrammarError.Type",
        "key.typeusr" : "$s3PwZ12GrammarErrorOmD",
        "key.usr" : "s:3PwZ12GrammarErrorO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
        "key.annotated_decl" : "<Declaration>@frozen struct Dictionary&lt;Key, Value&gt; where Key : <Type usr=\"s:SH\">Hashable<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.fileprivate",
            "key.length" : 11,
            "key.offset" : 409
          }
        ],
        "key.bodylength" : 138,
        "key.bodyoffset" : 443,
        "key.doc.comment" : "We extend basic Dictionaries to support query containment for simplicity.",
        "key.doc.declaration" : "struct Dictionary<Key, Value> where Key : Hashable",
        "key.doc.discussion" : [
          {
            "Para" : "A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays."
          },
          {
            "Para" : "Create a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary."
          },
          {
            "Para" : "Here’s how you would create a dictionary of HTTP response codes and their related messages:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `responseMessages` variable is inferred to have type `[Int: String]`. The `Key` type of the dictionary is `Int`, and the `Value` type of the dictionary is `String`."
          },
          {
            "Para" : "To create a dictionary with no key-value pairs, use an empty dictionary literal (`[:]`)."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Any type that conforms to the `Hashable` protocol can be used as a dictionary’s `Key` type, including all of Swift’s basic types. You can use your own custom types as dictionary keys by making them conform to the `Hashable` protocol."
          },
          {
            "Para" : "The most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript."
          },
          {
            "Para" : "The next example uses key-based subscripting of the `responseMessages` dictionary with two keys that exist in the dictionary and one that does not."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isn’t yet a part of the dictionary."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Update an existing value by assigning a new value to a key that already exists in the dictionary. If you assign `nil` to an existing key, the key and its associated value are removed. The following example updates the value for the `404` code to be simply “Not found” and removes the key-value pair for the `500` code entirely."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "In a mutable `Dictionary` instance, you can modify in place a value that you’ve accessed through a keyed subscript. The code sample below declares a dictionary called `interestingNumbers` with string keys and values that are integer arrays, then sorts each array in-place in descending order."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Every dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using a `for`-`in` loop, decomposing each key-value pair into the elements of a tuple."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and don’t need the fast key lookup that `Dictionary` provides, see the `KeyValuePairs` type for an alternative."
          },
          {
            "Para" : "You can search a dictionary’s contents for a particular value using the `contains(where:)` or `firstIndex(where:)` methods supplied by default implementation. The following example checks to see if `imagePaths` contains any paths in the `\"\/glyphs\"` directory:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Note that in this example, `imagePaths` is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A dictionary’s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification."
          },
          {
            "Para" : "When you know how many new values you’re adding to a dictionary, use the `init(minimumCapacity:)` initializer to allocate the correct amount of buffer."
          },
          {
            "Para" : "You can bridge between `Dictionary` and `NSDictionary` using the `as` operator. For bridging to be possible, the `Key` and `Value` types of a dictionary must be classes, `@objc` protocols, or types that bridge to Foundation types."
          },
          {
            "Para" : "Bridging from `Dictionary` to `NSDictionary` always takes O(1) time and space. When the dictionary’s `Key` and `Value` types are neither classes nor `@objc` protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O()."
          },
          {
            "Para" : "Bridging from `NSDictionary` to `Dictionary` first calls the `copy(with:)` method (`- copyWithZone:` in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of `NSDictionary` that are already immutable, `copy(with:)` usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances of `NSDictionary` and `Dictionary` share buffer using the same copy-on-write optimization that is used when two instances of `Dictionary` share buffer."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Dictionary<\/Name><USR>s:SD<\/USR><Declaration>struct Dictionary&lt;Key, Value&gt; where Key : Hashable<\/Declaration><CommentParts><Abstract><Para>A collection whose elements are key-value pairs.<\/Para><\/Abstract><Discussion><Para>A dictionary is a type of hash table, providing fast access to the entries it contains. Each entry in the table is identified using its key, which is a hashable type such as a string or number. You use that key to retrieve the corresponding value, which can be any object. In other languages, similar data types are known as hashes or associated arrays.<\/Para><Para>Create a new dictionary by using a dictionary literal. A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets. You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.<\/Para><Para>Here’s how you would create a dictionary of HTTP response codes and their related messages:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var responseMessages = [200: \"OK\",]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                        403: \"Access forbidden\",]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                        404: \"File not found\",]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                        500: \"Internal server error\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>responseMessages<\/codeVoice> variable is inferred to have type <codeVoice>[Int: String]<\/codeVoice>. The <codeVoice>Key<\/codeVoice> type of the dictionary is <codeVoice>Int<\/codeVoice>, and the <codeVoice>Value<\/codeVoice> type of the dictionary is <codeVoice>String<\/codeVoice>.<\/Para><Para>To create a dictionary with no key-value pairs, use an empty dictionary literal (<codeVoice>[:]<\/codeVoice>).<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var emptyDict: [String: String] = [:]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Any type that conforms to the <codeVoice>Hashable<\/codeVoice> protocol can be used as a dictionary’s <codeVoice>Key<\/codeVoice> type, including all of Swift’s basic types. You can use your own custom types as dictionary keys by making them conform to the <codeVoice>Hashable<\/codeVoice> protocol.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Getting and Setting Dictionary Values<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>The most common way to access values in a dictionary is to use a key as a subscript. Subscripting with a key takes the following form:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(responseMessages[200])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"OK\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.<\/Para><Para>The next example uses key-based subscripting of the <codeVoice>responseMessages<\/codeVoice> dictionary with two keys that exist in the dictionary and one that does not.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let httpResponseCodes = [200, 403, 301]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for code in httpResponseCodes {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    if let message = responseMessages[code] {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        print(\"Response \\(code): \\(message)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    } else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[        print(\"Unknown response \\(code)\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    }]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Response 200: OK\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Response 403: Access Forbidden\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Unknown response 301\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can also update, modify, or remove keys and values from a dictionary using the key-based subscript. To add a new key-value pair, assign a value to a key that isn’t yet a part of the dictionary.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[responseMessages[301] = \"Moved permanently\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(responseMessages[301])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"Moved permanently\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Update an existing value by assigning a new value to a key that already exists in the dictionary. If you assign <codeVoice>nil<\/codeVoice> to an existing key, the key and its associated value are removed. The following example updates the value for the <codeVoice>404<\/codeVoice> code to be simply “Not found” and removes the key-value pair for the <codeVoice>500<\/codeVoice> code entirely.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[responseMessages[404] = \"Not found\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[responseMessages[500] = nil]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(responseMessages)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[301: \"Moved permanently\", 200: \"OK\", 403: \"Access forbidden\", 404: \"Not found\"]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>In a mutable <codeVoice>Dictionary<\/codeVoice> instance, you can modify in place a value that you’ve accessed through a keyed subscript. The code sample below declares a dictionary called <codeVoice>interestingNumbers<\/codeVoice> with string keys and values that are integer arrays, then sorts each array in-place in descending order.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var interestingNumbers = [\"primes\": [2, 3, 5, 7, 11, 13, 17],]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                          \"triangular\": [1, 3, 6, 10, 15, 21, 28],]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                          \"hexagonal\": [1, 6, 15, 28, 45, 66, 91]]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for key in interestingNumbers.keys {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    interestingNumbers[key]?.sort(by: >)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(interestingNumbers[\"primes\"]!)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[17, 13, 11, 7, 5, 3, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Iterating Over the Contents of a Dictionary<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Every dictionary is an unordered collection of key-value pairs. You can iterate over a dictionary using a <codeVoice>for<\/codeVoice>-<codeVoice>in<\/codeVoice> loop, decomposing each key-value pair into the elements of a tuple.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let imagePaths = [\"star\": \"\/glyphs\/star.png\",]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                  \"portrait\": \"\/images\/content\/portrait.jpg\",]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[                  \"spacer\": \"\/images\/shared\/spacer.gif\"]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for (name, path) in imagePaths {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"The path to '\\(name)' is '\\(path)'.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"The path to 'star' is '\/glyphs\/star.png'.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"The path to 'portrait' is '\/images\/content\/portrait.jpg'.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"The path to 'spacer' is '\/images\/shared\/spacer.gif'.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable. If you need an ordered collection of key-value pairs and don’t need the fast key lookup that <codeVoice>Dictionary<\/codeVoice> provides, see the <codeVoice>KeyValuePairs<\/codeVoice> type for an alternative.<\/Para><Para>You can search a dictionary’s contents for a particular value using the <codeVoice>contains(where:)<\/codeVoice> or <codeVoice>firstIndex(where:)<\/codeVoice> methods supplied by default implementation. The following example checks to see if <codeVoice>imagePaths<\/codeVoice> contains any paths in the <codeVoice>&quot;\/glyphs&quot;<\/codeVoice> directory:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix(\"\/glyphs\") })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let index = glyphIndex {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"The '\\(imagePaths[index].key)' image is a glyph.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[} else {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"No glyphs found!\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"The 'star' image is a glyph.\")]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Note that in this example, <codeVoice>imagePaths<\/codeVoice> is subscripted using a dictionary index. Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(imagePaths[glyphIndex!])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"(\"star\", \"\/glyphs\/star.png\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>A dictionary’s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer. When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.<\/Para><Para>When you know how many new values you’re adding to a dictionary, use the <codeVoice>init(minimumCapacity:)<\/codeVoice> initializer to allocate the correct amount of buffer.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Bridging Between Dictionary and NSDictionary<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can bridge between <codeVoice>Dictionary<\/codeVoice> and <codeVoice>NSDictionary<\/codeVoice> using the <codeVoice>as<\/codeVoice> operator. For bridging to be possible, the <codeVoice>Key<\/codeVoice> and <codeVoice>Value<\/codeVoice> types of a dictionary must be classes, <codeVoice>@objc<\/codeVoice> protocols, or types that bridge to Foundation types.<\/Para><Para>Bridging from <codeVoice>Dictionary<\/codeVoice> to <codeVoice>NSDictionary<\/codeVoice> always takes O(1) time and space. When the dictionary’s <codeVoice>Key<\/codeVoice> and <codeVoice>Value<\/codeVoice> types are neither classes nor <codeVoice>@objc<\/codeVoice> protocols, any required bridging of elements occurs at the first access of each element. For this reason, the first operation that uses the contents of the dictionary may take O(<emphasis>n<\/emphasis>).<\/Para><Para>Bridging from <codeVoice>NSDictionary<\/codeVoice> to <codeVoice>Dictionary<\/codeVoice> first calls the <codeVoice>copy(with:)<\/codeVoice> method (<codeVoice>- copyWithZone:<\/codeVoice> in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time. For instances of <codeVoice>NSDictionary<\/codeVoice> that are already immutable, <codeVoice>copy(with:)<\/codeVoice> usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified. The instances of <codeVoice>NSDictionary<\/codeVoice> and <codeVoice>Dictionary<\/codeVoice> share buffer using the same copy-on-write optimization that is used when two instances of <codeVoice>Dictionary<\/codeVoice> share buffer.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Dictionary",
        "key.doc.type" : "Class",
        "key.doclength" : 78,
        "key.docoffset" : 331,
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.attribute.builtin><syntaxtype.attribute.name>@frozen<\/syntaxtype.attribute.name><\/syntaxtype.attribute.builtin> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Dictionary<\/decl.name>&lt;<decl.generic_type_param usr=\"s:SD3Keyxmfp\"><decl.generic_type_param.name>Key<\/decl.generic_type_param.name><\/decl.generic_type_param>, <decl.generic_type_param usr=\"s:SD5Valueq_mfp\"><decl.generic_type_param.name>Value<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Key : <ref.protocol usr=\"s:SH\">Hashable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.struct>",
        "key.groupname" : "Collection\/HashedCollections",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 161,
        "key.modulename" : "Swift",
        "key.name" : "Dictionary",
        "key.namelength" : 10,
        "key.nameoffset" : 431,
        "key.offset" : 421,
        "key.parsed_declaration" : "fileprivate extension Dictionary",
        "key.parsed_scope.end" : 16,
        "key.parsed_scope.start" : 11,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>func contains(_ key: <Type usr=\"s:SD3PwZE3Keyxmfp\">Key<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.bodylength" : 37,
            "key.bodyoffset" : 542,
            "key.doc.column" : 10,
            "key.doc.comment" : "Checks whether a key is present in the dictionary.",
            "key.doc.declaration" : "func contains(_ key: Key) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"13\" column=\"10\"><Name>contains(_:)<\/Name><USR>s:SD3PwZE8contains33_8F373873B05105130C6EC9A9BFE5F27ELLySbxF<\/USR><Declaration>func contains(_ key: Key) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para>Checks whether a key is present in the dictionary.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 13,
            "key.doc.name" : "contains(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 55,
            "key.docoffset" : 448,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>contains<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>key<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:SD3PwZE3Keyxmfp\">Key<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.groupname" : "Collection\/HashedCollections",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 73,
            "key.name" : "contains(_:)",
            "key.namelength" : 20,
            "key.nameoffset" : 512,
            "key.offset" : 507,
            "key.parsed_declaration" : "func contains(_ key: Key) -> Bool",
            "key.parsed_scope.end" : 15,
            "key.parsed_scope.start" : 13,
            "key.substructure" : [

            ],
            "key.typename" : "<Key, Value where Key : Hashable> (Dictionary<Key, Value>) -> (Key) -> Bool",
            "key.typeusr" : "$sySbxcD",
            "key.usr" : "s:SD3PwZE8contains33_8F373873B05105130C6EC9A9BFE5F27ELLySbxF"
          }
        ],
        "key.typename" : "Dictionary<Key, Value>.Type",
        "key.typeusr" : "$sSDyxq_GmD",
        "key.usr" : "s:SD"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public struct Grammar<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 888
          }
        ],
        "key.bodylength" : 7611,
        "key.bodyoffset" : 911,
        "key.doc.column" : 15,
        "key.doc.comment" : "A `Grammar` is a collection of productions. A basic knowledge of formal\ngrammars is assumed. See the [Wikipedia article](https:\/\/en.wikipedia.org\/wiki\/Formal_grammar)\nfor more information.\n\nOnce built, a `Grammar` can be used for parsing by using the\n`Grammar.parse(inputTokens:)` function.",
        "key.doc.declaration" : "public struct Grammar",
        "key.doc.discussion" : [
          {
            "Para" : "Once built, a `Grammar` can be used for parsing by using the `Grammar.parse(inputTokens:)` function."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"26\" column=\"15\"><Name>Grammar<\/Name><USR>s:3PwZ7GrammarV<\/USR><Declaration>public struct Grammar<\/Declaration><CommentParts><Abstract><Para>A <codeVoice>Grammar<\/codeVoice> is a collection of productions. A basic knowledge of formal grammars is assumed. See the <Link href=\"https:\/\/en.wikipedia.org\/wiki\/Formal_grammar\">Wikipedia article<\/Link> for more information.<\/Para><\/Abstract><Discussion><Para>Once built, a <codeVoice>Grammar<\/codeVoice> can be used for parsing by using the <codeVoice>Grammar.parse(inputTokens:)<\/codeVoice> function.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 26,
        "key.doc.name" : "Grammar",
        "key.doc.type" : "Class",
        "key.doclength" : 303,
        "key.docoffset" : 584,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Grammar<\/decl.name><\/decl.struct>",
        "key.kind" : "source.lang.swift.decl.struct",
        "key.length" : 7628,
        "key.name" : "Grammar",
        "key.namelength" : 7,
        "key.nameoffset" : 902,
        "key.offset" : 895,
        "key.parsed_declaration" : "public struct Grammar",
        "key.parsed_scope.end" : 194,
        "key.parsed_scope.start" : 26,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static let startSymbol: <Type usr=\"s:SS\">String<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1072
              }
            ],
            "key.doc.column" : 23,
            "key.doc.comment" : "All `Grammar`s must contain a top-level start symbol to indicate the\nroot of the grammar. An error will be thrown if this is not satisfied.",
            "key.doc.declaration" : "public static let startSymbol: String",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"29\" column=\"23\"><Name>startSymbol<\/Name><USR>s:3PwZ7GrammarV11startSymbolSSvpZ<\/USR><Declaration>public static let startSymbol: String<\/Declaration><CommentParts><Abstract><Para>All <codeVoice>Grammar<\/codeVoice>s must contain a top-level start symbol to indicate the root of the grammar. An error will be thrown if this is not satisfied.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 29,
            "key.doc.name" : "startSymbol",
            "key.doc.type" : "Other",
            "key.doclength" : 152,
            "key.docoffset" : 916,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.var.static><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>startSymbol<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type><\/decl.var.static>",
            "key.kind" : "source.lang.swift.decl.var.static",
            "key.length" : 32,
            "key.name" : "startSymbol",
            "key.namelength" : 11,
            "key.nameoffset" : 1090,
            "key.offset" : 1079,
            "key.parsed_declaration" : "public static let startSymbol = \"START\"",
            "key.parsed_scope.end" : 29,
            "key.parsed_scope.start" : 29,
            "key.typename" : "String",
            "key.typeusr" : "$sSSD",
            "key.usr" : "s:3PwZ7GrammarV11startSymbolSSvpZ"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public private(set) var tokenMap: [<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type> : <Type usr=\"s:3PwZ3Taga\">Tag<\/Type>] {\n  get\n  }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.setter_access.private",
                "key.length" : 12,
                "key.offset" : 1258
              },
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1251
              }
            ],
            "key.doc.column" : 29,
            "key.doc.comment" : "A map of token symbols to generated tags. This is useful for producing\ninput strings of tokens for the PwZ algorithm.",
            "key.doc.declaration" : "public private(set) var tokenMap: [Symbol : Tag] {\n    get\n    }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"33\" column=\"29\"><Name>tokenMap<\/Name><USR>s:3PwZ7GrammarV8tokenMapSDySSSiGvp<\/USR><Declaration>public private(set) var tokenMap: [Symbol : Tag] {\n    get\n    }<\/Declaration><CommentParts><Abstract><Para>A map of token symbols to generated tags. This is useful for producing input strings of tokens for the PwZ algorithm.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 33,
            "key.doc.name" : "tokenMap",
            "key.doc.type" : "Other",
            "key.doclength" : 130,
            "key.docoffset" : 1117,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>private<\/syntaxtype.keyword>(set) <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>tokenMap<\/decl.name>: <decl.var.type>[<ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias> : <ref.typealias usr=\"s:3PwZ3Taga\">Tag<\/ref.typealias>]<\/decl.var.type> {\n  get\n  }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 28,
            "key.name" : "tokenMap",
            "key.namelength" : 8,
            "key.nameoffset" : 1275,
            "key.offset" : 1271,
            "key.parsed_declaration" : "public private(set) var tokenMap: [Symbol : Tag]",
            "key.parsed_scope.end" : 33,
            "key.parsed_scope.start" : 33,
            "key.setter_accessibility" : "source.lang.swift.accessibility.private",
            "key.typename" : "[String : Int]",
            "key.typeusr" : "$sSDySSSiGD",
            "key.usr" : "s:3PwZ7GrammarV8tokenMapSDySSSiGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public let root: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1433
              }
            ],
            "key.doc.column" : 16,
            "key.doc.comment" : "The root `Expression` of the grammar after initialization. Use this for\nperforming derivations over the grammar.",
            "key.doc.declaration" : "public let root: Expression",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"36\" column=\"16\"><Name>root<\/Name><USR>s:3PwZ7GrammarV4rootAA10ExpressionCvp<\/USR><Declaration>public let root: Expression<\/Declaration><CommentParts><Abstract><Para>The root <codeVoice>Expression<\/codeVoice> of the grammar after initialization. Use this for performing derivations over the grammar.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 36,
            "key.doc.name" : "root",
            "key.doc.type" : "Other",
            "key.doclength" : 125,
            "key.docoffset" : 1304,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>root<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 20,
            "key.name" : "root",
            "key.namelength" : 4,
            "key.nameoffset" : 1444,
            "key.offset" : 1440,
            "key.parsed_declaration" : "public let root: Expression",
            "key.parsed_scope.end" : 36,
            "key.parsed_scope.start" : 36,
            "key.typename" : "Expression",
            "key.typeusr" : "$s3PwZ10ExpressionCD",
            "key.usr" : "s:3PwZ7GrammarV4rootAA10ExpressionCvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(fromAbstractProductions abstractProductions: [<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type> : <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>]) throws<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1860
              }
            ],
            "key.bodylength" : 4962,
            "key.bodyoffset" : 1953,
            "key.doc.column" : 12,
            "key.doc.comment" : "Initializes a new grammar from a dictionary mapping production names to\nproductions.\n\n- Parameters:\n    - abstractProductions: A dictionary mapping non-terminal production\n                           names to `AbstractGrammar` production\n                           descriptions.\n- Throws: Any `GrammarError` that results during initialization.",
            "key.doc.declaration" : "public init(fromAbstractProductions abstractProductions: [Symbol : AbstractGrammar]) throws",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"48\" column=\"12\"><Name>init(fromAbstractProductions:)<\/Name><USR>s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc<\/USR><Declaration>public init(fromAbstractProductions abstractProductions: [Symbol : AbstractGrammar]) throws<\/Declaration><CommentParts><Abstract><Para>Initializes a new grammar from a dictionary mapping production names to productions.<\/Para><\/Abstract><Parameters><Parameter><Name>abstractProductions<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>A dictionary mapping non-terminal production names to <codeVoice>AbstractGrammar<\/codeVoice> production descriptions.<\/Para><\/Discussion><\/Parameter><\/Parameters><ThrowsDiscussion><Para>Any <codeVoice>GrammarError<\/codeVoice> that results during initialization.<\/Para><\/ThrowsDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 48,
            "key.doc.name" : "init(fromAbstractProductions:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "A dictionary mapping non-terminal production names to `AbstractGrammar` production descriptions."
                  }
                ],
                "name" : "abstractProductions"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 389,
            "key.docoffset" : 1466,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>fromAbstractProductions<\/decl.var.parameter.argument_label> <decl.var.parameter.name>abstractProductions<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias> : <ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum>]<\/decl.var.parameter.type><\/decl.var.parameter>) <syntaxtype.keyword>throws<\/syntaxtype.keyword><\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 5049,
            "key.name" : "init(fromAbstractProductions:)",
            "key.namelength" : 77,
            "key.nameoffset" : 1867,
            "key.offset" : 1867,
            "key.parsed_declaration" : "public init(fromAbstractProductions abstractProductions: [Symbol : AbstractGrammar]) throws",
            "key.parsed_scope.end" : 148,
            "key.parsed_scope.start" : 48,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ7GrammarV17dictionaryLiteralACSS_AA08AbstractB0Otd_tcfc\">init(dictionaryLiteral:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.kind" : "source.lang.swift.syntaxtype.comment.mark",
                "key.length" : 63,
                "key.name" : "TODO: Is there a better way to implement this? One that doesn't",
                "key.namelength" : 0,
                "key.nameoffset" : 0,
                "key.offset" : 2027
              },
              {
                "key.annotated_decl" : "<Declaration>let productions: [<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type> : <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>productions<\/decl.name>: <decl.var.type>[<ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias> : <ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 327,
                "key.name" : "productions",
                "key.namelength" : 11,
                "key.nameoffset" : 2472,
                "key.offset" : 2468,
                "key.parsed_declaration" : "let productions = abstractProductions.keys.reduce(into: [Symbol : Expression]()) {\n    (productions, symbol) in\n    productions[symbol] = Expression(memoizationRecord: Sentinel.of(MemoizationRecord.self),\n                                   expressionCase: .Tok(token: Sentinel.of(Token.self)))\n}",
                "key.parsed_scope.end" : 60,
                "key.parsed_scope.start" : 60,
                "key.typename" : "[String : Expression]",
                "key.typeusr" : "$sSDySS3PwZ10ExpressionCGD",
                "key.usr" : "s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc11productionsL_SDySSAA10ExpressionCGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var nextTokenTag: <Type usr=\"s:3PwZ3Taga\">Tag<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>nextTokenTag<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ3Taga\">Tag<\/ref.typealias><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "nextTokenTag",
                "key.namelength" : 12,
                "key.nameoffset" : 3645,
                "key.offset" : 3641,
                "key.parsed_declaration" : "var nextTokenTag: Tag = 0",
                "key.parsed_scope.end" : 83,
                "key.parsed_scope.start" : 83,
                "key.typename" : "Int",
                "key.typeusr" : "$sSiD",
                "key.usr" : "s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc12nextTokenTagL_Sivp"
              },
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func processSubgrammar(_ subgrammar: <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>, withSymbol symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>) -&gt; <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
                "key.bodylength" : 2103,
                "key.bodyoffset" : 4456,
                "key.doc.column" : 14,
                "key.doc.comment" : "Recursively builds an `Expression` from a given `AbstractGrammar`. The\ntop-level productions must have names supplied by the\n`abstractProductions` dictionary, but child expressions are named\nautomatically. Terminal symbols take their matching string literal as\ntheir name.\n\n- Parameters\n    - subgrammar: The `AbstractGrammar` being processed right now.\n    - symbol: The name given to the `subgrammar` (if needed) based on\n              the shape of its parent.\n- Returns: An `Expression` corresponding to the description given by\n           the `subgrammar`.",
                "key.doc.declaration" : "func processSubgrammar(_ subgrammar: AbstractGrammar, withSymbol symbol: Symbol) -> Expression",
                "key.doc.discussion" : [
                  {
                    "List-Bullet" : ""
                  }
                ],
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"99\" column=\"14\"><Name>processSubgrammar(_:withSymbol:)<\/Name><USR>s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc17processSubgrammarL__10withSymbolAA10ExpressionCAF_SStF<\/USR><Declaration>func processSubgrammar(_ subgrammar: AbstractGrammar, withSymbol symbol: Symbol) -&gt; Expression<\/Declaration><CommentParts><Abstract><Para>Recursively builds an <codeVoice>Expression<\/codeVoice> from a given <codeVoice>AbstractGrammar<\/codeVoice>. The top-level productions must have names supplied by the <codeVoice>abstractProductions<\/codeVoice> dictionary, but child expressions are named automatically. Terminal symbols take their matching string literal as their name.<\/Para><\/Abstract><ResultDiscussion><Para>An <codeVoice>Expression<\/codeVoice> corresponding to the description given by the <codeVoice>subgrammar<\/codeVoice>.<\/Para><\/ResultDiscussion><Discussion><List-Bullet><Item><Para>Parameters<\/Para><List-Bullet><Item><Para>subgrammar: The <codeVoice>AbstractGrammar<\/codeVoice> being processed right now.<\/Para><\/Item><Item><Para>symbol: The name given to the <codeVoice>subgrammar<\/codeVoice> (if needed) based on the shape of its parent.<\/Para><\/Item><\/List-Bullet><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Function>",
                "key.doc.line" : 99,
                "key.doc.name" : "processSubgrammar(_:withSymbol:)",
                "key.doc.result_discussion" : [
                  {
                    "Para" : "An `Expression` corresponding to the description given by the `subgrammar`."
                  }
                ],
                "key.doc.type" : "Function",
                "key.doclength" : 675,
                "key.docoffset" : 3676,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>processSubgrammar<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>subgrammar<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withSymbol<\/decl.var.parameter.argument_label> <decl.var.parameter.name>symbol<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.function.returntype><\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 2200,
                "key.name" : "processSubgrammar(_:withSymbol:)",
                "key.namelength" : 75,
                "key.nameoffset" : 4365,
                "key.offset" : 4360,
                "key.parsed_declaration" : "func processSubgrammar(_ subgrammar: AbstractGrammar, withSymbol symbol: Symbol) -> Expression",
                "key.parsed_scope.end" : 139,
                "key.parsed_scope.start" : 99,
                "key.substructure" : [

                ],
                "key.typename" : "(AbstractGrammar, String) -> Expression",
                "key.typeusr" : "$s_10withSymbol3PwZ10ExpressionCAB15AbstractGrammarO_SStcD",
                "key.usr" : "s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc17processSubgrammarL__10withSymbolAA10ExpressionCAF_SStF"
              }
            ],
            "key.typename" : "(Grammar.Type) -> ([String : AbstractGrammar]) throws -> Grammar",
            "key.typeusr" : "$s23fromAbstractProductions3PwZ7GrammarVSDySSAB0bE0OG_tKcD",
            "key.usr" : "s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func tokenizeStrings(_ strings: [<Type usr=\"s:SS\">String<\/Type>]) throws -&gt; [<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 7265
              }
            ],
            "key.bodylength" : 70,
            "key.bodyoffset" : 7333,
            "key.doc.column" : 17,
            "key.doc.comment" : "Converts a sequence of strings into `Token`s for parsing.\n\n- Parameters:\n    - strings: An array of strings representing token symbols.\n- Returns: An array of `Token`s.\n- Throws: `GrammarError.NoTagForSymbol` if any of the given strings do not\n          match any terminal symbols in the grammar.",
            "key.doc.declaration" : "public func tokenizeStrings(_ strings: [String]) throws -> [Token]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"159\" column=\"17\"><Name>tokenizeStrings(_:)<\/Name><USR>s:3PwZ7GrammarV15tokenizeStringsySaySi3tag_SS6symboltGSaySSGKF<\/USR><Declaration>public func tokenizeStrings(_ strings: [String]) throws -&gt; [Token]<\/Declaration><CommentParts><Abstract><Para>Converts a sequence of strings into <codeVoice>Token<\/codeVoice>s for parsing.<\/Para><\/Abstract><Parameters><Parameter><Name>strings<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>An array of strings representing token symbols.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>An array of <codeVoice>Token<\/codeVoice>s.<\/Para><\/ResultDiscussion><ThrowsDiscussion><Para><codeVoice>GrammarError.NoTagForSymbol<\/codeVoice> if any of the given strings do not match any terminal symbols in the grammar.<\/Para><\/ThrowsDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 159,
            "key.doc.name" : "tokenizeStrings(_:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "An array of strings representing token symbols."
                  }
                ],
                "name" : "strings"
              }
            ],
            "key.doc.result_discussion" : [
              {
                "Para" : "An array of `Token`s."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 338,
            "key.docoffset" : 6922,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>tokenizeStrings<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>strings<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.struct usr=\"s:SS\">String<\/ref.struct>]<\/decl.var.parameter.type><\/decl.var.parameter>) <syntaxtype.keyword>throws<\/syntaxtype.keyword> -&gt; <decl.function.returntype>[<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 132,
            "key.name" : "tokenizeStrings(_:)",
            "key.namelength" : 36,
            "key.nameoffset" : 7277,
            "key.offset" : 7272,
            "key.parsed_declaration" : "public func tokenizeStrings(_ strings: [String]) throws -> [Token]",
            "key.parsed_scope.end" : 161,
            "key.parsed_scope.start" : 159,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ7GrammarV15tokenizeStringsySays6ResultOySi3tag_SS6symboltAA0B5ErrorOGGSaySSGF\">tokenizeStrings(_: [String]) -&gt; [Result&lt;Token, GrammarError&gt;]<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(Grammar) -> ([String]) throws -> [(tag: Int, symbol: String)]",
            "key.typeusr" : "$sySaySi3tag_SS6symboltGSaySSGKcD",
            "key.usr" : "s:3PwZ7GrammarV15tokenizeStringsySaySi3tag_SS6symboltGSaySSGKF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func tokenizeStrings(_ strings: [<Type usr=\"s:SS\">String<\/Type>]) -&gt; [<Type usr=\"s:s6ResultO\">Result<\/Type>&lt;<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>, <Type usr=\"s:3PwZ12GrammarErrorO\">GrammarError<\/Type>&gt;]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 7836
              }
            ],
            "key.bodylength" : 269,
            "key.bodyoffset" : 7919,
            "key.doc.column" : 17,
            "key.doc.comment" : "Converts a sequence of strings into `Token`s for parsing. The result is a\nlist of `Result<Token, GrammarError>` items so individual failing cases can\nbe addressed as needed.\n\n- Parameters:\n    - strings: An array of strings representing token symbols.\n- Returns: An array of potential tokens (or errors, when a string does not\n           correspond to a tag in the grammar).",
            "key.doc.declaration" : "public func tokenizeStrings(_ strings: [String]) -> [Result<Token, GrammarError>]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"173\" column=\"17\"><Name>tokenizeStrings(_:)<\/Name><USR>s:3PwZ7GrammarV15tokenizeStringsySays6ResultOySi3tag_SS6symboltAA0B5ErrorOGGSaySSGF<\/USR><Declaration>public func tokenizeStrings(_ strings: [String]) -&gt; [Result&lt;Token, GrammarError&gt;]<\/Declaration><CommentParts><Abstract><Para>Converts a sequence of strings into <codeVoice>Token<\/codeVoice>s for parsing. The result is a list of <codeVoice>Result&lt;Token, GrammarError&gt;<\/codeVoice> items so individual failing cases can be addressed as needed.<\/Para><\/Abstract><Parameters><Parameter><Name>strings<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>An array of strings representing token symbols.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>An array of potential tokens (or errors, when a string does not correspond to a tag in the grammar).<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 173,
            "key.doc.name" : "tokenizeStrings(_:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "An array of strings representing token symbols."
                  }
                ],
                "name" : "strings"
              }
            ],
            "key.doc.result_discussion" : [
              {
                "Para" : "An array of potential tokens (or errors, when a string does not correspond to a tag in the grammar)."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 421,
            "key.docoffset" : 7410,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>tokenizeStrings<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>strings<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.struct usr=\"s:SS\">String<\/ref.struct>]<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.enum usr=\"s:s6ResultO\">Result<\/ref.enum>&lt;<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>, <ref.enum usr=\"s:3PwZ12GrammarErrorO\">GrammarError<\/ref.enum>&gt;]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 346,
            "key.name" : "tokenizeStrings(_:)",
            "key.namelength" : 36,
            "key.nameoffset" : 7848,
            "key.offset" : 7843,
            "key.parsed_declaration" : "public func tokenizeStrings(_ strings: [String]) -> [Result<Token, GrammarError>]",
            "key.parsed_scope.end" : 182,
            "key.parsed_scope.start" : 173,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ7GrammarV15tokenizeStringsySaySi3tag_SS6symboltGSaySSGKF\">tokenizeStrings(_: [String]) throws -&gt; [Token]<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(Grammar) -> ([String]) -> [Result<(tag: Int, symbol: String), GrammarError>]",
            "key.typeusr" : "$sySays6ResultOySi3tag_SS6symbolt3PwZ12GrammarErrorOGGSaySSGcD",
            "key.usr" : "s:3PwZ7GrammarV15tokenizeStringsySays6ResultOySi3tag_SS6symboltAA0B5ErrorOGGSaySSGF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func parse(inputTokens tokens: [<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>]) -&gt; [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 8386
              }
            ],
            "key.bodylength" : 70,
            "key.bodyoffset" : 8450,
            "key.doc.column" : 17,
            "key.doc.comment" : "Parses the grammar using the given input tokens.\n\n- Parameters:\n    - tokens: An array of `Token`s to parse.\n- Returns: A list of resulting `Expression`s.",
            "key.doc.declaration" : "public func parse(inputTokens tokens: [Token]) -> [Expression]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"191\" column=\"17\"><Name>parse(inputTokens:)<\/Name><USR>s:3PwZ7GrammarV5parse11inputTokensSayAA10ExpressionCGSaySi3tag_SS6symboltG_tF<\/USR><Declaration>public func parse(inputTokens tokens: [Token]) -&gt; [Expression]<\/Declaration><CommentParts><Abstract><Para>Parses the grammar using the given input tokens.<\/Para><\/Abstract><Parameters><Parameter><Name>tokens<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>An array of <codeVoice>Token<\/codeVoice>s to parse.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>A list of resulting <codeVoice>Expression<\/codeVoice>s.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 191,
            "key.doc.name" : "parse(inputTokens:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "An array of `Token`s to parse."
                  }
                ],
                "name" : "tokens"
              }
            ],
            "key.doc.result_discussion" : [
              {
                "Para" : "A list of resulting `Expression`s."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 186,
            "key.docoffset" : 8195,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>parse<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>inputTokens<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tokens<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>]<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 128,
            "key.name" : "parse(inputTokens:)",
            "key.namelength" : 34,
            "key.nameoffset" : 8398,
            "key.offset" : 8393,
            "key.parsed_declaration" : "public func parse(inputTokens tokens: [Token]) -> [Expression]",
            "key.parsed_scope.end" : 193,
            "key.parsed_scope.start" : 191,
            "key.substructure" : [

            ],
            "key.typename" : "(Grammar) -> ([(tag: Int, symbol: String)]) -> [Expression]",
            "key.typeusr" : "$s11inputTokensSay3PwZ10ExpressionCGSaySi3tag_SS6symboltG_tcD",
            "key.usr" : "s:3PwZ7GrammarV5parse11inputTokensSayAA10ExpressionCGSaySi3tag_SS6symboltG_tF"
          }
        ],
        "key.typename" : "Grammar.Type",
        "key.typeusr" : "$s3PwZ7GrammarVmD",
        "key.usr" : "s:3PwZ7GrammarV"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public struct Grammar<\/Declaration>",
        "key.bodylength" : 2073,
        "key.bodyoffset" : 8668,
        "key.doc.column" : 15,
        "key.doc.comment" : "For convenience, we extend the `Grammar` to be expressible as a dictionary\nliteral.",
        "key.doc.declaration" : "public struct Grammar",
        "key.doc.discussion" : [
          {
            "Para" : "Once built, a `Grammar` can be used for parsing by using the `Grammar.parse(inputTokens:)` function."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"26\" column=\"15\"><Name>Grammar<\/Name><USR>s:3PwZ7GrammarV<\/USR><Declaration>public struct Grammar<\/Declaration><CommentParts><Abstract><Para>A <codeVoice>Grammar<\/codeVoice> is a collection of productions. A basic knowledge of formal grammars is assumed. See the <Link href=\"https:\/\/en.wikipedia.org\/wiki\/Formal_grammar\">Wikipedia article<\/Link> for more information.<\/Para><\/Abstract><Discussion><Para>Once built, a <codeVoice>Grammar<\/codeVoice> can be used for parsing by using the <codeVoice>Grammar.parse(inputTokens:)<\/codeVoice> function.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 26,
        "key.doc.name" : "Grammar",
        "key.doc.type" : "Class",
        "key.doclength" : 92,
        "key.docoffset" : 8525,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 30,
            "key.offset" : 8636
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Grammar<\/decl.name><\/decl.struct>",
        "key.inheritedtypes" : [
          {
            "key.name" : "ExpressibleByDictionaryLiteral"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 2125,
        "key.name" : "Grammar",
        "key.namelength" : 7,
        "key.nameoffset" : 8627,
        "key.offset" : 8617,
        "key.parsed_declaration" : "extension Grammar: ExpressibleByDictionaryLiteral",
        "key.parsed_scope.end" : 255,
        "key.parsed_scope.start" : 198,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(dictionaryLiteral elements: (<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>, <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>)...)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 10097
              }
            ],
            "key.bodylength" : 571,
            "key.bodyoffset" : 10168,
            "key.doc.column" : 12,
            "key.doc.comment" : "Initializes a `Grammar` from a dictionary literal. Together with the\nconvenience initializers and operators for `AbstractGrammar`s, this allows\nfor a convenient way to create a new `Grammar` from scratch.\n\nFor example, consider the following BNF grammar where `S` represents the\nstart symbol:\n\n    S      ::= expr\n    expr   ::= term\n             | expr '+' term\n             | expr '-' term\n    term   ::= factor\n             | term '*' factor\n             | term '\/' factor\n    factor ::= 'int'\n             | '-' factor\n             | '(' expr ')'\n\nWe can generate the grammar described like so:\n\n    let grammar: Grammar =\n      [ \"START\": \"expr\"\n      , \"expr\":\n          [ \"term\"\n          , \"expr\" ++ \"+\" ++ \"term\"\n          , \"expr\" ++ \"-\" ++ \"term\" ]\n      , \"term\":\n          [ \"factor\"\n          , \"term\" ++ \"*\" ++ \"factor\"\n          , \"term\" ++ \"\/\" ++ \"factor\" ]\n      , \"factor\":\n          [ \"int\"\n          , \"-\" ++ \"factor\"\n          , \"(\" ++ \"expr\" ++ \")\" ]\n      ]\n\nIf the grammar described is somehow invalid, a fatal error occurs. I\nrecommend not writing invalid grammar literals.\n\n- Parameters:\n    - elements: A sequence of `Symbol`-`AbstractGrammar` pairs from which\n                to create a `Grammar`.",
            "key.doc.declaration" : "public init(dictionaryLiteral elements: (Symbol, AbstractGrammar)...)",
            "key.doc.discussion" : [
              {
                "Para" : "For example, consider the following BNF grammar where `S` represents the start symbol:"
              },
              {
                "CodeListing" : ""
              },
              {
                "Para" : "We can generate the grammar described like so:"
              },
              {
                "CodeListing" : ""
              },
              {
                "Para" : "If the grammar described is somehow invalid, a fatal error occurs. I recommend not writing invalid grammar literals."
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"243\" column=\"12\"><Name>init(dictionaryLiteral:)<\/Name><USR>s:3PwZ7GrammarV17dictionaryLiteralACSS_AA08AbstractB0Otd_tcfc<\/USR><Declaration>public init(dictionaryLiteral elements: (Symbol, AbstractGrammar)...)<\/Declaration><CommentParts><Abstract><Para>Initializes a <codeVoice>Grammar<\/codeVoice> from a dictionary literal. Together with the convenience initializers and operators for <codeVoice>AbstractGrammar<\/codeVoice>s, this allows for a convenient way to create a new <codeVoice>Grammar<\/codeVoice> from scratch.<\/Para><\/Abstract><Parameters><Parameter><Name>elements<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>A sequence of <codeVoice>Symbol<\/codeVoice>-<codeVoice>AbstractGrammar<\/codeVoice> pairs from which to create a <codeVoice>Grammar<\/codeVoice>.<\/Para><\/Discussion><\/Parameter><\/Parameters><Discussion><Para>For example, consider the following BNF grammar where <codeVoice>S<\/codeVoice> represents the start symbol:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[S      ::= expr]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[expr   ::= term]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | expr '+' term]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | expr '-' term]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[term   ::= factor]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | term '*' factor]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | term '\/' factor]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[factor ::= 'int']]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | '-' factor]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[         | '(' expr ')']]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>We can generate the grammar described like so:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let grammar: Grammar =]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[  [ \"START\": \"expr\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[  , \"expr\":]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      [ \"term\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"expr\" ++ \"+\" ++ \"term\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"expr\" ++ \"-\" ++ \"term\" ]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[  , \"term\":]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      [ \"factor\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"term\" ++ \"*\" ++ \"factor\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"term\" ++ \"\/\" ++ \"factor\" ]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[  , \"factor\":]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      [ \"int\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"-\" ++ \"factor\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[      , \"(\" ++ \"expr\" ++ \")\" ]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[  ]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>If the grammar described is somehow invalid, a fatal error occurs. I recommend not writing invalid grammar literals.<\/Para><\/Discussion><\/CommentParts><\/Function>",
            "key.doc.line" : 243,
            "key.doc.name" : "init(dictionaryLiteral:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "A sequence of `Symbol`-`AbstractGrammar` pairs from which to create a `Grammar`."
                  }
                ],
                "name" : "elements"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 1419,
            "key.docoffset" : 8673,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>dictionaryLiteral<\/decl.var.parameter.argument_label> <decl.var.parameter.name>elements<\/decl.var.parameter.name>: <decl.var.parameter.type><tuple>(<tuple.element><tuple.element.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/tuple.element.type><\/tuple.element>)<\/tuple><\/decl.var.parameter.type>...<\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 636,
            "key.name" : "init(dictionaryLiteral:)",
            "key.namelength" : 62,
            "key.nameoffset" : 10104,
            "key.offset" : 10104,
            "key.overrides" : [
              {
                "key.usr" : "s:s30ExpressibleByDictionaryLiteralP010dictionaryD0x3KeyQz_5ValueQztd_tcfc"
              }
            ],
            "key.parsed_declaration" : "public init(dictionaryLiteral elements: (Symbol, AbstractGrammar)...)",
            "key.parsed_scope.end" : 254,
            "key.parsed_scope.start" : 243,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ7GrammarV23fromAbstractProductionsACSDySSAA0dB0OG_tKcfc\">init(fromAbstractProductions:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let abstractProductions: [<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type> : <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>]<\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>abstractProductions<\/decl.name>: <decl.var.type>[<ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias> : <ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum>]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 334,
                "key.name" : "abstractProductions",
                "key.namelength" : 19,
                "key.nameoffset" : 10181,
                "key.offset" : 10177,
                "key.parsed_declaration" : "let abstractProductions = Dictionary.init(elements, uniquingKeysWith: {\n                                                        (lv, rv) in\n                                                        fatalError(\"Duplicate non-terminal name in grammar: \\(lv)\")\n                                                    })",
                "key.parsed_scope.end" : 244,
                "key.parsed_scope.start" : 244,
                "key.typename" : "[String : AbstractGrammar]",
                "key.typeusr" : "$sSDySS3PwZ15AbstractGrammarOGD",
                "key.usr" : "s:3PwZ7GrammarV17dictionaryLiteralACSS_AA08AbstractB0Otd_tcfc19abstractProductionsL_SDySSAFGvp"
              }
            ],
            "key.typename" : "(Grammar.Type) -> ((String, AbstractGrammar)...) -> Grammar",
            "key.typeusr" : "$s17dictionaryLiteral3PwZ7GrammarVSS_AB08AbstractD0Otd_tcD",
            "key.usr" : "s:3PwZ7GrammarV17dictionaryLiteralACSS_AA08AbstractB0Otd_tcfc"
          }
        ],
        "key.typename" : "Grammar.Type",
        "key.typeusr" : "$s3PwZ7GrammarVmD",
        "key.usr" : "s:3PwZ7GrammarV"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public indirect enum AbstractGrammar<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.indirect",
            "key.length" : 8,
            "key.offset" : 10800
          },
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 10793
          }
        ],
        "key.bodylength" : 280,
        "key.bodyoffset" : 10831,
        "key.doc.column" : 22,
        "key.doc.comment" : "A simplified grammar specification language.",
        "key.doc.declaration" : "public indirect enum AbstractGrammar",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"258\" column=\"22\"><Name>AbstractGrammar<\/Name><USR>s:3PwZ15AbstractGrammarO<\/USR><Declaration>public indirect enum AbstractGrammar<\/Declaration><CommentParts><Abstract><Para>A simplified grammar specification language.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 258,
        "key.doc.name" : "AbstractGrammar",
        "key.doc.type" : "Other",
        "key.doclength" : 49,
        "key.docoffset" : 10744,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>indirect<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>AbstractGrammar<\/decl.name><\/decl.enum>",
        "key.kind" : "source.lang.swift.decl.enum",
        "key.length" : 303,
        "key.name" : "AbstractGrammar",
        "key.namelength" : 15,
        "key.nameoffset" : 10814,
        "key.offset" : 10809,
        "key.parsed_declaration" : "public indirect enum AbstractGrammar",
        "key.parsed_scope.end" : 265,
        "key.parsed_scope.start" : 258,
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 19,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 10886,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Symbol(<Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>)<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Either a terminal or non-terminal symbol.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"260\" column=\"10\"><Name>Symbol(_:)<\/Name><USR>s:3PwZ15AbstractGrammarO6SymbolyACSScACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Either a terminal or non-terminal symbol.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 260,
                "key.doc.name" : "Symbol(_:)",
                "key.doc.type" : "Other",
                "key.doclength" : 46,
                "key.docoffset" : 10836,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Symbol<\/decl.name>(<decl.var.parameter><decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 14,
                "key.name" : "Symbol(_:)",
                "key.namelength" : 14,
                "key.nameoffset" : 10891,
                "key.offset" : 10891,
                "key.parsed_declaration" : "case Symbol(Symbol)",
                "key.parsed_scope.end" : 260,
                "key.parsed_scope.start" : 260,
                "key.typename" : "(AbstractGrammar.Type) -> (String) -> AbstractGrammar",
                "key.typeusr" : "$sy3PwZ15AbstractGrammarOSScACmcD",
                "key.usr" : "s:3PwZ15AbstractGrammarO6SymbolyACSScACmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 37,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 10978,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Concatenation([<Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>])<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "A sequence of expressions that must be considered in-order.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"262\" column=\"10\"><Name>Concatenation(_:)<\/Name><USR>s:3PwZ15AbstractGrammarO13ConcatenationyACSayACGcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>A sequence of expressions that must be considered in-order.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 262,
                "key.doc.name" : "Concatenation(_:)",
                "key.doc.type" : "Other",
                "key.doclength" : 64,
                "key.docoffset" : 10910,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Concatenation<\/decl.name>(<decl.var.parameter><decl.var.parameter.type>[<ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum>]<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 32,
                "key.name" : "Concatenation(_:)",
                "key.namelength" : 32,
                "key.nameoffset" : 10983,
                "key.offset" : 10983,
                "key.parsed_declaration" : "case Concatenation([AbstractGrammar])",
                "key.parsed_scope.end" : 262,
                "key.parsed_scope.start" : 262,
                "key.typename" : "(AbstractGrammar.Type) -> ([AbstractGrammar]) -> AbstractGrammar",
                "key.typeusr" : "$sy3PwZ15AbstractGrammarOSayACGcACmcD",
                "key.usr" : "s:3PwZ15AbstractGrammarO13ConcatenationyACSayACGcACmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 35,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 11075,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Alternation([<Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>])<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "A collection of non-deterministic expressions.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"264\" column=\"10\"><Name>Alternation(_:)<\/Name><USR>s:3PwZ15AbstractGrammarO11AlternationyACSayACGcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>A collection of non-deterministic expressions.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 264,
                "key.doc.name" : "Alternation(_:)",
                "key.doc.type" : "Other",
                "key.doclength" : 51,
                "key.docoffset" : 11020,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Alternation<\/decl.name>(<decl.var.parameter><decl.var.parameter.type>[<ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum>]<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 30,
                "key.name" : "Alternation(_:)",
                "key.namelength" : 30,
                "key.nameoffset" : 11080,
                "key.offset" : 11080,
                "key.parsed_declaration" : "case Alternation([AbstractGrammar])",
                "key.parsed_scope.end" : 264,
                "key.parsed_scope.start" : 264,
                "key.typename" : "(AbstractGrammar.Type) -> ([AbstractGrammar]) -> AbstractGrammar",
                "key.typeusr" : "$sy3PwZ15AbstractGrammarOSayACGcACmcD",
                "key.usr" : "s:3PwZ15AbstractGrammarO11AlternationyACSayACGcACmF"
              }
            ]
          }
        ],
        "key.typename" : "AbstractGrammar.Type",
        "key.typeusr" : "$s3PwZ15AbstractGrammarOmD",
        "key.usr" : "s:3PwZ15AbstractGrammarO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public indirect enum AbstractGrammar<\/Declaration>",
        "key.bodylength" : 154,
        "key.bodyoffset" : 11261,
        "key.doc.column" : 22,
        "key.doc.comment" : "Allow `AbstractGrammar.Symbol`s to be created from string literals for\nconvenience.",
        "key.doc.declaration" : "public indirect enum AbstractGrammar",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"258\" column=\"22\"><Name>AbstractGrammar<\/Name><USR>s:3PwZ15AbstractGrammarO<\/USR><Declaration>public indirect enum AbstractGrammar<\/Declaration><CommentParts><Abstract><Para>A simplified grammar specification language.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 258,
        "key.doc.name" : "AbstractGrammar",
        "key.doc.type" : "Other",
        "key.doclength" : 92,
        "key.docoffset" : 11114,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 26,
            "key.offset" : 11233
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>indirect<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>AbstractGrammar<\/decl.name><\/decl.enum>",
        "key.inheritedtypes" : [
          {
            "key.name" : "ExpressibleByStringLiteral"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 210,
        "key.name" : "AbstractGrammar",
        "key.namelength" : 15,
        "key.nameoffset" : 11216,
        "key.offset" : 11206,
        "key.parsed_declaration" : "extension AbstractGrammar: ExpressibleByStringLiteral",
        "key.parsed_scope.end" : 274,
        "key.parsed_scope.start" : 269,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(stringLiteral string: <Type usr=\"s:SS\">String<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 11333
              }
            ],
            "key.bodylength" : 37,
            "key.bodyoffset" : 11376,
            "key.doc.column" : 12,
            "key.doc.comment" : "Creates an `AbstractGrammar.Symbol` from a string literal.",
            "key.doc.declaration" : "public init(stringLiteral string: String)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"271\" column=\"12\"><Name>init(stringLiteral:)<\/Name><USR>s:3PwZ15AbstractGrammarO13stringLiteralACSS_tcfc<\/USR><Declaration>public init(stringLiteral string: String)<\/Declaration><CommentParts><Abstract><Para>Creates an <codeVoice>AbstractGrammar.Symbol<\/codeVoice> from a string literal.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 271,
            "key.doc.name" : "init(stringLiteral:)",
            "key.doc.type" : "Function",
            "key.doclength" : 63,
            "key.docoffset" : 11266,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>stringLiteral<\/decl.var.parameter.argument_label> <decl.var.parameter.name>string<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 74,
            "key.name" : "init(stringLiteral:)",
            "key.namelength" : 34,
            "key.nameoffset" : 11340,
            "key.offset" : 11340,
            "key.overrides" : [
              {
                "key.usr" : "s:s26ExpressibleByStringLiteralP06stringD0x0cD4TypeQz_tcfc"
              }
            ],
            "key.parsed_declaration" : "public init(stringLiteral string: String)",
            "key.parsed_scope.end" : 273,
            "key.parsed_scope.start" : 271,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ15AbstractGrammarO12arrayLiteralA2Cd_tcfc\">init(arrayLiteral:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(AbstractGrammar.Type) -> (String) -> AbstractGrammar",
            "key.typeusr" : "$s13stringLiteral3PwZ15AbstractGrammarOSS_tcD",
            "key.usr" : "s:3PwZ15AbstractGrammarO13stringLiteralACSS_tcfc"
          }
        ],
        "key.typename" : "AbstractGrammar.Type",
        "key.typeusr" : "$s3PwZ15AbstractGrammarOmD",
        "key.usr" : "s:3PwZ15AbstractGrammarO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public indirect enum AbstractGrammar<\/Declaration>",
        "key.bodylength" : 493,
        "key.bodyoffset" : 11548,
        "key.doc.column" : 22,
        "key.doc.comment" : "Allow `AbstractGrammar.Alternation`s to be created from array literals.",
        "key.doc.declaration" : "public indirect enum AbstractGrammar",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"258\" column=\"22\"><Name>AbstractGrammar<\/Name><USR>s:3PwZ15AbstractGrammarO<\/USR><Declaration>public indirect enum AbstractGrammar<\/Declaration><CommentParts><Abstract><Para>A simplified grammar specification language.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 258,
        "key.doc.name" : "AbstractGrammar",
        "key.doc.type" : "Other",
        "key.doclength" : 76,
        "key.docoffset" : 11418,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 25,
            "key.offset" : 11521
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>indirect<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>AbstractGrammar<\/decl.name><\/decl.enum>",
        "key.inheritedtypes" : [
          {
            "key.name" : "ExpressibleByArrayLiteral"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 548,
        "key.name" : "AbstractGrammar",
        "key.namelength" : 15,
        "key.nameoffset" : 11504,
        "key.offset" : 11494,
        "key.parsed_declaration" : "extension AbstractGrammar: ExpressibleByArrayLiteral",
        "key.parsed_scope.end" : 290,
        "key.parsed_scope.start" : 277,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(arrayLiteral elements: <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>...)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 11767
              }
            ],
            "key.bodylength" : 215,
            "key.bodyoffset" : 11824,
            "key.doc.column" : 12,
            "key.doc.comment" : "Creates an `AbstractGrammar.Alternation` from an array of\n`AbstractGrammar`s. If the array only contains one element, it will be\nused as the sole production (i.e., no alternate is created).",
            "key.doc.declaration" : "public init(arrayLiteral elements: AbstractGrammar...)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"281\" column=\"12\"><Name>init(arrayLiteral:)<\/Name><USR>s:3PwZ15AbstractGrammarO12arrayLiteralA2Cd_tcfc<\/USR><Declaration>public init(arrayLiteral elements: AbstractGrammar...)<\/Declaration><CommentParts><Abstract><Para>Creates an <codeVoice>AbstractGrammar.Alternation<\/codeVoice> from an array of <codeVoice>AbstractGrammar<\/codeVoice>s. If the array only contains one element, it will be used as the sole production (i.e., no alternate is created).<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 281,
            "key.doc.name" : "init(arrayLiteral:)",
            "key.doc.type" : "Function",
            "key.doclength" : 210,
            "key.docoffset" : 11553,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>arrayLiteral<\/decl.var.parameter.argument_label> <decl.var.parameter.name>elements<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.var.parameter.type>...<\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 266,
            "key.name" : "init(arrayLiteral:)",
            "key.namelength" : 48,
            "key.nameoffset" : 11774,
            "key.offset" : 11774,
            "key.overrides" : [
              {
                "key.usr" : "s:s25ExpressibleByArrayLiteralP05arrayD0x0cD7ElementQzd_tcfc"
              }
            ],
            "key.parsed_declaration" : "public init (arrayLiteral elements: AbstractGrammar...)",
            "key.parsed_scope.end" : 289,
            "key.parsed_scope.start" : 281,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ15AbstractGrammarO13stringLiteralACSS_tcfc\">init(stringLiteral:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(AbstractGrammar.Type) -> (AbstractGrammar...) -> AbstractGrammar",
            "key.typeusr" : "$s12arrayLiteral3PwZ15AbstractGrammarOADd_tcD",
            "key.usr" : "s:3PwZ15AbstractGrammarO12arrayLiteralA2Cd_tcfc"
          }
        ],
        "key.typename" : "AbstractGrammar.Type",
        "key.typeusr" : "$s3PwZ15AbstractGrammarOmD",
        "key.usr" : "s:3PwZ15AbstractGrammarO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public func ++ (lhs: <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>, rhs: <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type>) -&gt; <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 12233
          }
        ],
        "key.bodylength" : 352,
        "key.bodyoffset" : 12313,
        "key.doc.column" : 13,
        "key.doc.comment" : "Concatenates two `AbstractGrammar`s into a single\n`AbstractGrammar.Concatenation`.",
        "key.doc.declaration" : "public func ++ (lhs: AbstractGrammar, rhs: AbstractGrammar) -> AbstractGrammar",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift\" line=\"297\" column=\"13\"><Name>++(_:_:)<\/Name><USR>s:3PwZ2ppoiyAA15AbstractGrammarOAD_ADtF<\/USR><Declaration>public func ++ (lhs: AbstractGrammar, rhs: AbstractGrammar) -&gt; AbstractGrammar<\/Declaration><CommentParts><Abstract><Para>Concatenates two <codeVoice>AbstractGrammar<\/codeVoice>s into a single <codeVoice>AbstractGrammar.Concatenation<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
        "key.doc.line" : 297,
        "key.doc.name" : "++(_:_:)",
        "key.doc.type" : "Function",
        "key.doclength" : 91,
        "key.docoffset" : 12142,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
        "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>++ <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.function.returntype><\/decl.function.operator.infix>",
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.length" : 426,
        "key.name" : "++(_:_:)",
        "key.namelength" : 47,
        "key.nameoffset" : 12245,
        "key.offset" : 12240,
        "key.parsed_declaration" : "public func ++ (lhs: AbstractGrammar, rhs: AbstractGrammar) -> AbstractGrammar",
        "key.parsed_scope.end" : 308,
        "key.parsed_scope.start" : 297,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/Type><\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Grammar.swift",
            "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ15AbstractGrammarO\">AbstractGrammar<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>",
            "key.kind" : "source.lang.swift.decl.var.parameter",
            "key.length" : 3,
            "key.name" : "lhs",
            "key.offset" : 12249,
            "key.parent_loc" : 12245,
            "key.parsed_declaration" : "public func ++ (lhs",
            "key.parsed_scope.end" : 297,
            "key.parsed_scope.start" : 297,
            "key.typename" : "AbstractGrammar",
            "key.typeusr" : "$s3PwZ15AbstractGrammarOD",
            "key.usr" : "s:3PwZ2ppoiyAA15AbstractGrammarOAD_ADtF3lhsL_ADvp"
          }
        ],
        "key.typename" : "(AbstractGrammar, AbstractGrammar) -> AbstractGrammar",
        "key.typeusr" : "$sy3PwZ15AbstractGrammarOAC_ACtcD",
        "key.usr" : "s:3PwZ2ppoiyAA15AbstractGrammarOAD_ADtF"
      }
    ]
  }
}, {
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 16096,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>class ZipperParser<\/Declaration>",
        "key.bodylength" : 15348,
        "key.bodyoffset" : 332,
        "key.doc.column" : 7,
        "key.doc.comment" : "The `ZipperParser` enables parsing over a grammar using the algorithm described\nin the paper \"Parsing with Zippers\" by Darragh and Adams (ICFP 2020).\n\nIt's implemented as a class to make management of state and encapsulation of\nhelper methods more straightforward, but that's not strictly necessary.",
        "key.doc.declaration" : "class ZipperParser",
        "key.doc.discussion" : [
          {
            "Para" : "It’s implemented as a class to make management of state and encapsulation of helper methods more straightforward, but that’s not strictly necessary."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"8\" column=\"7\"><Name>ZipperParser<\/Name><USR>s:3PwZ12ZipperParserC<\/USR><Declaration>class ZipperParser<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ZipperParser<\/codeVoice> enables parsing over a grammar using the algorithm described in the paper “Parsing with Zippers” by Darragh and Adams (ICFP 2020).<\/Para><\/Abstract><Discussion><Para>It’s implemented as a class to make management of state and encapsulation of helper methods more straightforward, but that’s not strictly necessary.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 8,
        "key.doc.name" : "ZipperParser",
        "key.doc.type" : "Class",
        "key.doclength" : 311,
        "key.docoffset" : 0,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ZipperParser<\/decl.name><\/decl.class>",
        "key.kind" : "source.lang.swift.decl.class",
        "key.length" : 15369,
        "key.name" : "ZipperParser",
        "key.namelength" : 12,
        "key.nameoffset" : 318,
        "key.offset" : 312,
        "key.parsed_declaration" : "class ZipperParser",
        "key.parsed_scope.end" : 267,
        "key.parsed_scope.start" : 8,
        "key.runtime_name" : "_TtC4main12ZipperParser",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var worklist: [<Type usr=\"s:3PwZ6Zippera\">Zipper<\/Type>]<\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "Used for keeping track of resume-able `Zipper`s produced from parsing\natomic `Tok` productions.",
            "key.doc.declaration" : "var worklist: [PwZ.Zipper]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"11\" column=\"9\"><Name>worklist<\/Name><USR>s:3PwZ12ZipperParserC8worklistSayAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contexttGvp<\/USR><Declaration>var worklist: [PwZ.Zipper]<\/Declaration><CommentParts><Abstract><Para>Used for keeping track of resume-able <codeVoice>Zipper<\/codeVoice>s produced from parsing atomic <codeVoice>Tok<\/codeVoice> productions.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 11,
            "key.doc.name" : "worklist",
            "key.doc.type" : "Other",
            "key.doclength" : 108,
            "key.docoffset" : 337,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>worklist<\/decl.name>: <decl.var.type>[<ref.typealias usr=\"s:3PwZ6Zippera\">Zipper<\/ref.typealias>]<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 27,
            "key.name" : "worklist",
            "key.namelength" : 8,
            "key.nameoffset" : 453,
            "key.offset" : 449,
            "key.parsed_declaration" : "var worklist: [Zipper] = []",
            "key.parsed_scope.end" : 11,
            "key.parsed_scope.start" : 11,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "[(expression: ExpressionCase, context: MemoizationRecord)]",
            "key.typeusr" : "$sSay3PwZ14ExpressionCaseO10expression_AA17MemoizationRecordC7contexttGD",
            "key.usr" : "s:3PwZ12ZipperParserC8worklistSayAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contexttGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var tops: [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "Used for keeping track of completed parses resulting from parsing up\nto a `TopC` context.",
            "key.doc.declaration" : "var tops: [PwZ.Expression]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"14\" column=\"9\"><Name>tops<\/Name><USR>s:3PwZ12ZipperParserC4topsSayAA10ExpressionCGvp<\/USR><Declaration>var tops: [PwZ.Expression]<\/Declaration><CommentParts><Abstract><Para>Used for keeping track of completed parses resulting from parsing up to a <codeVoice>TopC<\/codeVoice> context.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 14,
            "key.doc.name" : "tops",
            "key.doc.type" : "Other",
            "key.doclength" : 102,
            "key.docoffset" : 481,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>tops<\/decl.name>: <decl.var.type>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 27,
            "key.name" : "tops",
            "key.namelength" : 4,
            "key.nameoffset" : 591,
            "key.offset" : 587,
            "key.parsed_declaration" : "var tops: [Expression] = []",
            "key.parsed_scope.end" : 14,
            "key.parsed_scope.start" : 14,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "[Expression]",
            "key.typeusr" : "$sSay3PwZ10ExpressionCGD",
            "key.usr" : "s:3PwZ12ZipperParserC4topsSayAA10ExpressionCGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>func derive(withToken token: <Type usr=\"s:3PwZ5Tokena\">Token<\/Type>, atPosition position: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type>, fromZipper zipper: <Type usr=\"s:3PwZ6Zippera\">Zipper<\/Type>)<\/Declaration>",
            "key.bodylength" : 9703,
            "key.bodyoffset" : 2076,
            "key.doc.column" : 10,
            "key.doc.comment" : "Derives the grammar with respect to the given token. A position is used to\nindex `MemoizationRecords` so we know when old records have gone stale.\n\nThe implementation is divided into four sub-functions, which can be divided\ninto two categories: two functions moving the current position *down* the\ngrammar, and two functions moving the current position *up* the grammar.\n\nThe theory of the procedure is given in the paper. This particular\nimplementation is more verbose than the paper's version. The hope is that\nthis version may be easier to read for those who prefer descriptive names.\nComments have been added in a few places to explain the general principles\nat play, but a more thorough discussion is, of course, left to the paper.\n\n- Parameters:\n    - token: The `Token` that we are taking the derivative with respect to.\n             In other words, we are attempting to see if one of the next\n             available atomic `Tok` positions in the grammar matches this\n             token, in which case the derivative is successful.\n    - position: The current index into the list of input `Token`s. This is\n                used to ensure we don't use stale memoization records.\n    - zipper: A representation of the \"current point\" in the grammar.",
            "key.doc.declaration" : "func derive(withToken token: Token, atPosition position: Position, fromZipper zipper: Zipper)",
            "key.doc.discussion" : [
              {
                "Para" : "The implementation is divided into four sub-functions, which can be divided into two categories: two functions moving the current position  the grammar, and two functions moving the current position  the grammar."
              },
              {
                "Para" : "The theory of the procedure is given in the paper. This particular implementation is more verbose than the paper’s version. The hope is that this version may be easier to read for those who prefer descriptive names. Comments have been added in a few places to explain the general principles at play, but a more thorough discussion is, of course, left to the paper."
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"39\" column=\"10\"><Name>derive(withToken:atPosition:fromZipper:)<\/Name><USR>s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF<\/USR><Declaration>func derive(withToken token: Token, atPosition position: Position, fromZipper zipper: Zipper)<\/Declaration><CommentParts><Abstract><Para>Derives the grammar with respect to the given token. A position is used to index <codeVoice>MemoizationRecords<\/codeVoice> so we know when old records have gone stale.<\/Para><\/Abstract><Parameters><Parameter><Name>token<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The <codeVoice>Token<\/codeVoice> that we are taking the derivative with respect to. In other words, we are attempting to see if one of the next available atomic <codeVoice>Tok<\/codeVoice> positions in the grammar matches this token, in which case the derivative is successful.<\/Para><\/Discussion><\/Parameter><Parameter><Name>position<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The current index into the list of input <codeVoice>Token<\/codeVoice>s. This is used to ensure we don’t use stale memoization records.<\/Para><\/Discussion><\/Parameter><Parameter><Name>zipper<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>A representation of the “current point” in the grammar.<\/Para><\/Discussion><\/Parameter><\/Parameters><Discussion><Para>The implementation is divided into four sub-functions, which can be divided into two categories: two functions moving the current position <emphasis>down<\/emphasis> the grammar, and two functions moving the current position <emphasis>up<\/emphasis> the grammar.<\/Para><Para>The theory of the procedure is given in the paper. This particular implementation is more verbose than the paper’s version. The hope is that this version may be easier to read for those who prefer descriptive names. Comments have been added in a few places to explain the general principles at play, but a more thorough discussion is, of course, left to the paper.<\/Para><\/Discussion><\/CommentParts><\/Function>",
            "key.doc.line" : 39,
            "key.doc.name" : "derive(withToken:atPosition:fromZipper:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The `Token` that we are taking the derivative with respect to. In other words, we are attempting to see if one of the next available atomic `Tok` positions in the grammar matches this token, in which case the derivative is successful."
                  }
                ],
                "name" : "token"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The current index into the list of input `Token`s. This is used to ensure we don’t use stale memoization records."
                  }
                ],
                "name" : "position"
              },
              {
                "discussion" : [
                  {
                    "Para" : "A representation of the “current point” in the grammar."
                  }
                ],
                "name" : "zipper"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 1356,
            "key.docoffset" : 620,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>derive<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>withToken<\/decl.var.parameter.argument_label> <decl.var.parameter.name>token<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>atPosition<\/decl.var.parameter.argument_label> <decl.var.parameter.name>position<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>fromZipper<\/decl.var.parameter.argument_label> <decl.var.parameter.name>zipper<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Zippera\">Zipper<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 9799,
            "key.name" : "derive(withToken:atPosition:fromZipper:)",
            "key.namelength" : 88,
            "key.nameoffset" : 1986,
            "key.offset" : 1981,
            "key.parsed_declaration" : "func derive(withToken token: Token, atPosition position: Position, fromZipper zipper: Zipper)",
            "key.parsed_scope.end" : 193,
            "key.parsed_scope.start" : 39,
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let tag: <Type usr=\"s:3PwZ3Taga\">Tag<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>tag<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ3Taga\">Tag<\/ref.typealias><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "tag",
                "key.namelength" : 3,
                "key.nameoffset" : 2124,
                "key.offset" : 2119,
                "key.parsed_declaration" : "let (tag, symbol) = token",
                "key.parsed_scope.end" : 41,
                "key.parsed_scope.start" : 41,
                "key.typename" : "Int",
                "key.typeusr" : "$sSiD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttFAHL_Sivp"
              },
              {
                "key.annotated_decl" : "<Declaration>let symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>symbol<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "symbol",
                "key.namelength" : 6,
                "key.nameoffset" : 2129,
                "key.offset" : 2119,
                "key.parsed_declaration" : "let (tag, symbol) = token",
                "key.parsed_scope.end" : 41,
                "key.parsed_scope.start" : 41,
                "key.typename" : "String",
                "key.typeusr" : "$sSSD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttFAIL_SSvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let expressionCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>expressionCase<\/decl.name>: <decl.var.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 48,
                "key.name" : "expressionCase",
                "key.namelength" : 14,
                "key.nameoffset" : 2158,
                "key.offset" : 2153,
                "key.parsed_declaration" : "let (expressionCase, memoizationRecord) = zipper",
                "key.parsed_scope.end" : 42,
                "key.parsed_scope.start" : 42,
                "key.typename" : "ExpressionCase",
                "key.typeusr" : "$s3PwZ14ExpressionCaseOD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0nM0L_AKvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>memoizationRecord<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 48,
                "key.name" : "memoizationRecord",
                "key.namelength" : 17,
                "key.nameoffset" : 2174,
                "key.offset" : 2153,
                "key.parsed_declaration" : "let (expressionCase, memoizationRecord) = zipper",
                "key.parsed_scope.end" : 42,
                "key.parsed_scope.start" : 42,
                "key.typename" : "MemoizationRecord",
                "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF011memoizationP0L_ANvp"
              },
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func deriveDown(fromContext context: <Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>, toExpression expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>)<\/Declaration>",
                "key.bodylength" : 1869,
                "key.bodyoffset" : 2299,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>deriveDown<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>fromContext<\/decl.var.parameter.argument_label> <decl.var.parameter.name>context<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>toExpression<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expression<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 1958,
                "key.name" : "deriveDown(fromContext:toExpression:)",
                "key.namelength" : 81,
                "key.nameoffset" : 2216,
                "key.offset" : 2211,
                "key.parsed_declaration" : "func deriveDown(fromContext context: ContextCase, toExpression expression: Expression)",
                "key.parsed_scope.end" : 72,
                "key.parsed_scope.start" : 44,
                "key.substructure" : [

                ],
                "key.typename" : "(ContextCase, Expression) -> ()",
                "key.typeusr" : "$s11fromContext12toExpressiony3PwZ0B4CaseO_AC0D0CtcD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0D4DownL_0I7Context02toL0yAA0sM0O_AA0L0CtF"
              },
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func deriveDown(fromMemoizationRecord memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>, toExpressionCase expressionCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>)<\/Declaration>",
                "key.bodylength" : 3112,
                "key.bodyoffset" : 4305,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>deriveDown<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>fromMemoizationRecord<\/decl.var.parameter.argument_label> <decl.var.parameter.name>memoizationRecord<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>toExpressionCase<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expressionCase<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 3239,
                "key.name" : "deriveDown(fromMemoizationRecord:toExpressionCase:)",
                "key.namelength" : 119,
                "key.nameoffset" : 4184,
                "key.offset" : 4179,
                "key.parsed_declaration" : "func deriveDown(fromMemoizationRecord memoizationRecord: MemoizationRecord, toExpressionCase expressionCase: ExpressionCase)",
                "key.parsed_scope.end" : 121,
                "key.parsed_scope.start" : 74,
                "key.substructure" : [

                ],
                "key.typename" : "(MemoizationRecord, ExpressionCase) -> ()",
                "key.typeusr" : "$s21fromMemoizationRecord16toExpressionCasey3PwZ0bC0C_AC0eF0OtcD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0D4DownL0_0ioP002tolM0yAN_AKtF"
              },
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func deriveUp(fromExpressionCase expressionCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>, toMemoizationRecord memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>)<\/Declaration>",
                "key.bodylength" : 862,
                "key.bodyoffset" : 7552,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>deriveUp<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>fromExpressionCase<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expressionCase<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>toMemoizationRecord<\/decl.var.parameter.argument_label> <decl.var.parameter.name>memoizationRecord<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 987,
                "key.name" : "deriveUp(fromExpressionCase:toMemoizationRecord:)",
                "key.namelength" : 117,
                "key.nameoffset" : 7433,
                "key.offset" : 7428,
                "key.parsed_declaration" : "func deriveUp(fromExpressionCase expressionCase: ExpressionCase, toMemoizationRecord memoizationRecord: MemoizationRecord)",
                "key.parsed_scope.end" : 136,
                "key.parsed_scope.start" : 123,
                "key.substructure" : [
                  {
                    "key.annotated_decl" : "<Declaration>let expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
                    "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                    "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>expression<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.type><\/decl.var.local>",
                    "key.kind" : "source.lang.swift.decl.var.local",
                    "key.length" : 59,
                    "key.name" : "expression",
                    "key.namelength" : 10,
                    "key.nameoffset" : 7703,
                    "key.offset" : 7699,
                    "key.parsed_declaration" : "let expression = Expression(expressionCase: expressionCase)",
                    "key.parsed_scope.end" : 126,
                    "key.parsed_scope.start" : 126,
                    "key.typename" : "Expression",
                    "key.typeusr" : "$s3PwZ10ExpressionCD",
                    "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0D2UpL_0ilM002tooP0yAK_ANtFALL_AA0L0Cvp"
                  }
                ],
                "key.typename" : "(ExpressionCase, MemoizationRecord) -> ()",
                "key.typeusr" : "$s18fromExpressionCase19toMemoizationRecordy3PwZ0bC0O_AC0eF0CtcD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0D2UpL_0ilM002tooP0yAK_ANtF"
              },
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func deriveUp(fromExpression expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>, toContext context: <Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>)<\/Declaration>",
                "key.bodylength" : 2761,
                "key.bodyoffset" : 8511,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>deriveUp<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>fromExpression<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expression<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>toContext<\/decl.var.parameter.argument_label> <decl.var.parameter.name>context<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 2848,
                "key.name" : "deriveUp(fromExpression:toContext:)",
                "key.namelength" : 79,
                "key.nameoffset" : 8430,
                "key.offset" : 8425,
                "key.parsed_declaration" : "func deriveUp(fromExpression expression: Expression, toContext context: ContextCase)",
                "key.parsed_scope.end" : 183,
                "key.parsed_scope.start" : 138,
                "key.substructure" : [

                ],
                "key.typename" : "(Expression, ContextCase) -> ()",
                "key.typeusr" : "$s14fromExpression9toContexty3PwZ0B0C_AC0D4CaseOtcD",
                "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF0D2UpL0_0iL09toContextyAA0L0C_AA0tM0OtF"
              }
            ],
            "key.typename" : "(ZipperParser) -> ((tag: Int, symbol: String), Int, (expression: ExpressionCase, context: MemoizationRecord)) -> ()",
            "key.typeusr" : "$s9withToken10atPosition10fromZipperySi3tag_SS6symbolt_Si3PwZ14ExpressionCaseO10expression_AF17MemoizationRecordC7contextttcD",
            "key.usr" : "s:3PwZ12ZipperParserC6derive9withToken10atPosition04fromB0ySi3tag_SS6symbolt_SiAA14ExpressionCaseO10expression_AA17MemoizationRecordC7contextttF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>private func initializeZipper(fromExpression expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; <Type usr=\"s:3PwZ6Zippera\">Zipper<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.private",
                "key.length" : 7,
                "key.offset" : 12377
              }
            ],
            "key.bodylength" : 1194,
            "key.bodyoffset" : 12457,
            "key.doc.column" : 18,
            "key.doc.comment" : "Wraps an expression in sufficient material that it will automatically parse\nwithout needing to add special cases to the parsing machinery. However, the\nresults produced will need to be unwrapped by a call to\n`unwrapTopExpression(_:)`.\n\n- Parameters:\n    - expression: The `Expression` representing the root of the grammar to\n                  be derived over.\n- Returns: A `Zipper` properly encoding the given `Expression` so that\n           calls to `derive(withToken:atPosition:fromZipper)` proceed as\n           expected.",
            "key.doc.declaration" : "private func initializeZipper(fromExpression expression: Expression) -> Zipper",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"208\" column=\"18\"><Name>initializeZipper(fromExpression:)<\/Name><USR>s:3PwZ12ZipperParserC010initializeB033_D3AF2067F1A21C190E7D34B06C19EADFLL14fromExpressionAA0P4CaseO10expression_AA17MemoizationRecordC7contexttAA0P0C_tF<\/USR><Declaration>private func initializeZipper(fromExpression expression: Expression) -&gt; Zipper<\/Declaration><CommentParts><Abstract><Para>Wraps an expression in sufficient material that it will automatically parse without needing to add special cases to the parsing machinery. However, the results produced will need to be unwrapped by a call to <codeVoice>unwrapTopExpression(_:)<\/codeVoice>.<\/Para><\/Abstract><Parameters><Parameter><Name>expression<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The <codeVoice>Expression<\/codeVoice> representing the root of the grammar to be derived over.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>A <codeVoice>Zipper<\/codeVoice> properly encoding the given <codeVoice>Expression<\/codeVoice> so that calls to <codeVoice>derive(withToken:atPosition:fromZipper)<\/codeVoice> proceed as expected.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 208,
            "key.doc.name" : "initializeZipper(fromExpression:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The `Expression` representing the root of the grammar to be derived over."
                  }
                ],
                "name" : "expression"
              }
            ],
            "key.doc.result_discussion" : [
              {
                "Para" : "A `Zipper` properly encoding the given `Expression` so that calls to `derive(withToken:atPosition:fromZipper)` proceed as expected."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 586,
            "key.docoffset" : 11786,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>private<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>initializeZipper<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>fromExpression<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expression<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ6Zippera\">Zipper<\/ref.typealias><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 1267,
            "key.name" : "initializeZipper(fromExpression:)",
            "key.namelength" : 55,
            "key.nameoffset" : 12390,
            "key.offset" : 12385,
            "key.parsed_declaration" : "private func initializeZipper(fromExpression expression: Expression) -> Zipper",
            "key.parsed_scope.end" : 221,
            "key.parsed_scope.start" : 208,
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let topMemoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>topMemoizationRecord<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 360,
                "key.name" : "topMemoizationRecord",
                "key.namelength" : 20,
                "key.nameoffset" : 12470,
                "key.offset" : 12466,
                "key.parsed_declaration" : "let topMemoizationRecord = MemoizationRecord(startPosition: Sentinel.of(Position.self),\n                                             endPosition: Sentinel.of(Position.self),\n                                             parentContexts: [.TopC],\n                                             resultExpression: Sentinel.of(Expression.self))",
                "key.parsed_scope.end" : 209,
                "key.parsed_scope.start" : 209,
                "key.typename" : "MemoizationRecord",
                "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
                "key.usr" : "s:3PwZ12ZipperParserC010initializeB033_D3AF2067F1A21C190E7D34B06C19EADFLL14fromExpressionAA0P4CaseO10expression_AA17MemoizationRecordC7contexttAA0P0C_tF03topsT0L_AKvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let seqMemoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>seqMemoizationRecord<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 716,
                "key.name" : "seqMemoizationRecord",
                "key.namelength" : 20,
                "key.nameoffset" : 12839,
                "key.offset" : 12835,
                "key.parsed_declaration" : "let seqMemoizationRecord = MemoizationRecord(startPosition: Sentinel.of(Position.self),\n                                             endPosition: Sentinel.of(Position.self),\n                                             parentContexts: [.SeqC(memoizationRecord: topMemoizationRecord,\n                                                                    symbol: Sentinel.of(Symbol.self),\n                                                                    leftExpressions: [],\n                                                                    rightExpressions: [expression])],\n                                             resultExpression: Sentinel.of(Expression.self))",
                "key.parsed_scope.end" : 213,
                "key.parsed_scope.start" : 213,
                "key.typename" : "MemoizationRecord",
                "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
                "key.usr" : "s:3PwZ12ZipperParserC010initializeB033_D3AF2067F1A21C190E7D34B06C19EADFLL14fromExpressionAA0P4CaseO10expression_AA17MemoizationRecordC7contexttAA0P0C_tF03seqsT0L_AKvp"
              }
            ],
            "key.typename" : "(ZipperParser) -> (Expression) -> (expression: ExpressionCase, context: MemoizationRecord)",
            "key.typeusr" : "$s14fromExpression3PwZ0B4CaseO10expression_AB17MemoizationRecordC7contexttAB0B0C_tcD",
            "key.usr" : "s:3PwZ12ZipperParserC010initializeB033_D3AF2067F1A21C190E7D34B06C19EADFLL14fromExpressionAA0P4CaseO10expression_AA17MemoizationRecordC7contexttAA0P0C_tF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>private func unwrapTopExpression(_ expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.private",
                "key.length" : 7,
                "key.offset" : 13961
              }
            ],
            "key.bodylength" : 421,
            "key.bodyoffset" : 14035,
            "key.doc.column" : 18,
            "key.doc.comment" : "Unwraps a top expression resulting from a completed parse. This essentially\njust undoes the work of `initializeZipper(fromExpression)`.\n\n- Parameters:\n    expression: An `Expression` resulting from a completed parse.\n- Returns: The unwrapped inner `Expression`.",
            "key.doc.declaration" : "private func unwrapTopExpression(_ expression: Expression) -> Expression",
            "key.doc.discussion" : [
              {
                "List-Bullet" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"231\" column=\"18\"><Name>unwrapTopExpression(_:)<\/Name><USR>s:3PwZ12ZipperParserC19unwrapTopExpression33_D3AF2067F1A21C190E7D34B06C19EADFLLyAA0F0CAGF<\/USR><Declaration>private func unwrapTopExpression(_ expression: Expression) -&gt; Expression<\/Declaration><CommentParts><Abstract><Para>Unwraps a top expression resulting from a completed parse. This essentially just undoes the work of <codeVoice>initializeZipper(fromExpression)<\/codeVoice>.<\/Para><\/Abstract><ResultDiscussion><Para>The unwrapped inner <codeVoice>Expression<\/codeVoice>.<\/Para><\/ResultDiscussion><Discussion><List-Bullet><Item><Para>Parameters: expression: An <codeVoice>Expression<\/codeVoice> resulting from a completed parse.<\/Para><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Function>",
            "key.doc.line" : 231,
            "key.doc.name" : "unwrapTopExpression(_:)",
            "key.doc.result_discussion" : [
              {
                "Para" : "The unwrapped inner `Expression`."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 298,
            "key.docoffset" : 13658,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>private<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>unwrapTopExpression<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expression<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 488,
            "key.name" : "unwrapTopExpression(_:)",
            "key.namelength" : 45,
            "key.nameoffset" : 13974,
            "key.offset" : 13969,
            "key.parsed_declaration" : "private func unwrapTopExpression(_ expression: Expression) -> Expression",
            "key.parsed_scope.end" : 240,
            "key.parsed_scope.start" : 231,
            "key.substructure" : [

            ],
            "key.typename" : "(ZipperParser) -> (Expression) -> Expression",
            "key.typeusr" : "$sy3PwZ10ExpressionCACcD",
            "key.usr" : "s:3PwZ12ZipperParserC19unwrapTopExpression33_D3AF2067F1A21C190E7D34B06C19EADFLLyAA0F0CAGF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>func parse(inputTokens tokens: [<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>], withGrammar grammar: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
            "key.bodylength" : 859,
            "key.bodyoffset" : 14819,
            "key.doc.column" : 10,
            "key.doc.comment" : "Parses a sequence of input tokens against a given grammar.\n\n- Parameters:\n    - tokens: A list of `Token`s representing the input string.\n    - grammar: The grammar to parse with respect to.\n- Returns: A list of parse trees.",
            "key.doc.declaration" : "func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -> [Expression]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"250\" column=\"10\"><Name>parse(inputTokens:withGrammar:)<\/Name><USR>s:3PwZ12ZipperParserC5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AHtF<\/USR><Declaration>func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -&gt; [Expression]<\/Declaration><CommentParts><Abstract><Para>Parses a sequence of input tokens against a given grammar.<\/Para><\/Abstract><Parameters><Parameter><Name>tokens<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>A list of <codeVoice>Token<\/codeVoice>s representing the input string.<\/Para><\/Discussion><\/Parameter><Parameter><Name>grammar<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The grammar to parse with respect to.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>A list of parse trees.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
            "key.doc.line" : 250,
            "key.doc.name" : "parse(inputTokens:withGrammar:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "A list of `Token`s representing the input string."
                  }
                ],
                "name" : "tokens"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The grammar to parse with respect to."
                  }
                ],
                "name" : "grammar"
              }
            ],
            "key.doc.result_discussion" : [
              {
                "Para" : "A list of parse trees."
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 261,
            "key.docoffset" : 14463,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>parse<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>inputTokens<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tokens<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>]<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withGrammar<\/decl.var.parameter.argument_label> <decl.var.parameter.name>grammar<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 950,
            "key.name" : "parse(inputTokens:withGrammar:)",
            "key.namelength" : 67,
            "key.nameoffset" : 14734,
            "key.offset" : 14729,
            "key.parsed_declaration" : "func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -> [Expression]",
            "key.parsed_scope.end" : 266,
            "key.parsed_scope.start" : 250,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.private",
                "key.annotated_decl" : "<Declaration>func parse(inputTokens tokens: [<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>], atPosition position: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type>) -&gt; [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
                "key.bodylength" : 636,
                "key.bodyoffset" : 14916,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>parse<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>inputTokens<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tokens<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>]<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>atPosition<\/decl.var.parameter.argument_label> <decl.var.parameter.name>position<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.function.returntype><\/decl.function.free>",
                "key.kind" : "source.lang.swift.decl.function.free",
                "key.length" : 725,
                "key.name" : "parse(inputTokens:atPosition:)",
                "key.namelength" : 65,
                "key.nameoffset" : 14833,
                "key.offset" : 14828,
                "key.parsed_declaration" : "func parse(inputTokens tokens: [Token], atPosition position: Position) -> [Expression]",
                "key.parsed_scope.end" : 263,
                "key.parsed_scope.start" : 251,
                "key.related_decls" : [
                  {
                    "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ12ZipperParserC5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AHtF\">parse(inputTokens:withGrammar:)<\/RelatedName>"
                  }
                ],
                "key.substructure" : [
                  {
                    "key.annotated_decl" : "<Declaration>let savedZippers: [<Type usr=\"s:3PwZ6Zippera\">Zipper<\/Type>]<\/Declaration>",
                    "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
                    "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>savedZippers<\/decl.name>: <decl.var.type>[<ref.typealias usr=\"s:3PwZ6Zippera\">Zipper<\/ref.typealias>]<\/decl.var.type><\/decl.var.local>",
                    "key.kind" : "source.lang.swift.decl.var.local",
                    "key.length" : 27,
                    "key.name" : "savedZippers",
                    "key.namelength" : 12,
                    "key.nameoffset" : 14933,
                    "key.offset" : 14929,
                    "key.parsed_declaration" : "let savedZippers = worklist",
                    "key.parsed_scope.end" : 252,
                    "key.parsed_scope.start" : 252,
                    "key.typename" : "[(expression: ExpressionCase, context: MemoizationRecord)]",
                    "key.typeusr" : "$sSay3PwZ14ExpressionCaseO10expression_AA17MemoizationRecordC7contexttGD",
                    "key.usr" : "s:3PwZ12ZipperParserC5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AHtFADL_AE10atPositionAiL_SitF12savedZippersL_SayAA0I4CaseO10expression_AA17MemoizationRecordC7contexttGvp"
                  }
                ],
                "key.typename" : "([(tag: Int, symbol: String)], Int) -> [Expression]",
                "key.typeusr" : "$s11inputTokens10atPositionSay3PwZ10ExpressionCGSaySi3tag_SS6symboltG_SitcD",
                "key.usr" : "s:3PwZ12ZipperParserC5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AHtFADL_AE10atPositionAiL_SitF"
              }
            ],
            "key.typename" : "(ZipperParser) -> ([(tag: Int, symbol: String)], Expression) -> [Expression]",
            "key.typeusr" : "$s11inputTokens11withGrammarSay3PwZ10ExpressionCGSaySi3tag_SS6symboltG_AEtcD",
            "key.usr" : "s:3PwZ12ZipperParserC5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AHtF"
          }
        ],
        "key.typename" : "ZipperParser.Type",
        "key.typeusr" : "$s3PwZ12ZipperParserCmD",
        "key.usr" : "s:3PwZ12ZipperParserC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public func parse(inputTokens tokens: [<Type usr=\"s:3PwZ5Tokena\">Token<\/Type>], withGrammar grammar: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>]<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 15921
          }
        ],
        "key.bodylength" : 76,
        "key.bodyoffset" : 16018,
        "key.doc.column" : 13,
        "key.doc.comment" : "Parses a sequence of input tokens against a given grammar.\n\n- Parameters:\n    - tokens: A list of `Token`s representing the input string.\n    - grammar: The grammar to parse with respect to.\n- Returns: A list of parse trees.",
        "key.doc.declaration" : "public func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -> [Expression]",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
        "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift\" line=\"277\" column=\"13\"><Name>parse(inputTokens:withGrammar:)<\/Name><USR>s:3PwZ5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AFtF<\/USR><Declaration>public func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -&gt; [Expression]<\/Declaration><CommentParts><Abstract><Para>Parses a sequence of input tokens against a given grammar.<\/Para><\/Abstract><Parameters><Parameter><Name>tokens<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>A list of <codeVoice>Token<\/codeVoice>s representing the input string.<\/Para><\/Discussion><\/Parameter><Parameter><Name>grammar<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The grammar to parse with respect to.<\/Para><\/Discussion><\/Parameter><\/Parameters><ResultDiscussion><Para>A list of parse trees.<\/Para><\/ResultDiscussion><\/CommentParts><\/Function>",
        "key.doc.line" : 277,
        "key.doc.name" : "parse(inputTokens:withGrammar:)",
        "key.doc.parameters" : [
          {
            "discussion" : [
              {
                "Para" : "A list of `Token`s representing the input string."
              }
            ],
            "name" : "tokens"
          },
          {
            "discussion" : [
              {
                "Para" : "The grammar to parse with respect to."
              }
            ],
            "name" : "grammar"
          }
        ],
        "key.doc.result_discussion" : [
          {
            "Para" : "A list of parse trees."
          }
        ],
        "key.doc.type" : "Function",
        "key.doclength" : 237,
        "key.docoffset" : 15683,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Parser.swift",
        "key.fully_annotated_decl" : "<decl.function.free><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>parse<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>inputTokens<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tokens<\/decl.var.parameter.name>: <decl.var.parameter.type>[<ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>]<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>withGrammar<\/decl.var.parameter.argument_label> <decl.var.parameter.name>grammar<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.function.returntype><\/decl.function.free>",
        "key.kind" : "source.lang.swift.decl.function.free",
        "key.length" : 167,
        "key.name" : "parse(inputTokens:withGrammar:)",
        "key.namelength" : 67,
        "key.nameoffset" : 15933,
        "key.offset" : 15928,
        "key.parsed_declaration" : "public func parse(inputTokens tokens: [Token], withGrammar grammar: Expression) -> [Expression]",
        "key.parsed_scope.end" : 279,
        "key.parsed_scope.start" : 277,
        "key.substructure" : [

        ],
        "key.typename" : "([(tag: Int, symbol: String)], Expression) -> [Expression]",
        "key.typeusr" : "$s11inputTokens11withGrammarSay3PwZ10ExpressionCGSaySi3tag_SS6symboltG_AEtcD",
        "key.usr" : "s:3PwZ5parse11inputTokens11withGrammarSayAA10ExpressionCGSaySi3tag_SS6symboltG_AFtF"
      }
    ]
  }
}, {
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 3254,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public class ReferenceArray&lt;Element&gt; : <Type usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/Type> where Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 179
          }
        ],
        "key.bodylength" : 1371,
        "key.bodyoffset" : 255,
        "key.doc.column" : 14,
        "key.doc.comment" : "The `ReferenceArray` is a wrapper around the standard `Array` that provides\nreference semantics for mutable array objects.\n\nOnly the necessary methods are implemented.",
        "key.doc.declaration" : "public class ReferenceArray<Element> : ExpressibleByArrayLiteral where Element : Equatable",
        "key.doc.discussion" : [
          {
            "Para" : "Only the necessary methods are implemented."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"7\" column=\"14\"><Name>ReferenceArray<\/Name><USR>s:3PwZ14ReferenceArrayC<\/USR><Declaration>public class ReferenceArray&lt;Element&gt; : ExpressibleByArrayLiteral where Element : Equatable<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ReferenceArray<\/codeVoice> is a wrapper around the standard <codeVoice>Array<\/codeVoice> that provides reference semantics for mutable array objects.<\/Para><\/Abstract><Discussion><Para>Only the necessary methods are implemented.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 7,
        "key.doc.name" : "ReferenceArray",
        "key.doc.type" : "Class",
        "key.doclength" : 178,
        "key.docoffset" : 0,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 25,
            "key.offset" : 228
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ReferenceArray<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "ExpressibleByArrayLiteral"
          }
        ],
        "key.kind" : "source.lang.swift.decl.class",
        "key.length" : 1441,
        "key.name" : "ReferenceArray",
        "key.namelength" : 14,
        "key.nameoffset" : 192,
        "key.offset" : 186,
        "key.parsed_declaration" : "public class ReferenceArray<Element: Equatable>: ExpressibleByArrayLiteral",
        "key.parsed_scope.end" : 55,
        "key.parsed_scope.start" : 7,
        "key.substructure" : [
          {
            "key.annotated_decl" : "<Declaration>Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
            "key.elements" : [
              {
                "key.kind" : "source.lang.swift.structure.elem.typeref",
                "key.length" : 9,
                "key.offset" : 216
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>Element<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
            "key.inheritedtypes" : [
              {
                "key.name" : "Equatable"
              }
            ],
            "key.kind" : "source.lang.swift.decl.generic_type_param",
            "key.length" : 18,
            "key.name" : "Element",
            "key.namelength" : 7,
            "key.nameoffset" : 207,
            "key.offset" : 207,
            "key.parsed_declaration" : "public class ReferenceArray<Element: Equatable",
            "key.parsed_scope.end" : 7,
            "key.parsed_scope.start" : 7,
            "key.typename" : "Element.Type",
            "key.typeusr" : "$sxmD",
            "key.usr" : "s:3PwZ14ReferenceArrayC7Elementxmfp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public typealias <Type usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/Type>&lt;Element&gt;.Element = <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 303
              }
            ],
            "key.doc.column" : 22,
            "key.doc.comment" : "The type of elements in the array.",
            "key.doc.declaration" : "public typealias PwZ.ReferenceArray<Element>.Element = Element",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"9\" column=\"22\"><Name>Element<\/Name><USR>s:3PwZ14ReferenceArrayC7Elementa<\/USR><Declaration>public typealias PwZ.ReferenceArray&lt;Element&gt;.Element = Element<\/Declaration><CommentParts><Abstract><Para>The type of elements in the array.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 9,
            "key.doc.name" : "Element",
            "key.doc.type" : "Other",
            "key.doclength" : 39,
            "key.docoffset" : 260,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <ref.class usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/ref.class>&lt;Element&gt;.<decl.name>Element<\/decl.name> = <ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param><\/decl.typealias>",
            "key.kind" : "source.lang.swift.decl.typealias",
            "key.length" : 27,
            "key.name" : "Element",
            "key.namelength" : 7,
            "key.nameoffset" : 320,
            "key.offset" : 310,
            "key.overrides" : [
              {
                "key.usr" : "s:ST7ElementQa"
              },
              {
                "key.usr" : "s:Sl7ElementQa"
              }
            ],
            "key.parsed_declaration" : "public typealias Element = Element",
            "key.parsed_scope.end" : 9,
            "key.parsed_scope.start" : 9,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/RelatedName>"
              }
            ],
            "key.typename" : "Element.Type",
            "key.typeusr" : "$sxmD",
            "key.usr" : "s:3PwZ14ReferenceArrayC7Elementa"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var items: [Element]<\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "The internal array that the class provides a reference to.",
            "key.doc.declaration" : "var items: [Element]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"12\" column=\"9\"><Name>items<\/Name><USR>s:3PwZ14ReferenceArrayC5itemsSayxGvp<\/USR><Declaration>var items: [Element]<\/Declaration><CommentParts><Abstract><Para>The internal array that the class provides a reference to.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 12,
            "key.doc.name" : "items",
            "key.doc.type" : "Other",
            "key.doclength" : 63,
            "key.docoffset" : 343,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>items<\/decl.name>: <decl.var.type>[Element]<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 25,
            "key.name" : "items",
            "key.namelength" : 5,
            "key.nameoffset" : 414,
            "key.offset" : 410,
            "key.parsed_declaration" : "var items: [Element] = []",
            "key.parsed_scope.end" : 12,
            "key.parsed_scope.start" : 12,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "[Element]",
            "key.typeusr" : "$sSayxGD",
            "key.usr" : "s:3PwZ14ReferenceArrayC5itemsSayxGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init&lt;S&gt;(_ sequence: <Type usr=\"s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc1SL_qd__mfp\">S<\/Type>) where Element == S.Element, S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 508
              }
            ],
            "key.bodylength" : 77,
            "key.bodyoffset" : 591,
            "key.doc.column" : 12,
            "key.doc.comment" : "Initializes the array from an existing sequence of values.",
            "key.doc.declaration" : "public init<S>(_ sequence: S) where Element == S.Element, S : Sequence",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"15\" column=\"12\"><Name>init(_:)<\/Name><USR>s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc<\/USR><Declaration>public init&lt;S&gt;(_ sequence: S) where Element == S.Element, S : Sequence<\/Declaration><CommentParts><Abstract><Para>Initializes the array from an existing sequence of values.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 15,
            "key.doc.name" : "init(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 63,
            "key.docoffset" : 441,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc1SL_qd__mfp\"><decl.generic_type_param.name>S<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>sequence<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc1SL_qd__mfp\">S<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element == S.Element<\/decl.generic_type_requirement>, <decl.generic_type_requirement>S : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_requirement><\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 154,
            "key.name" : "init(_:)",
            "key.namelength" : 32,
            "key.nameoffset" : 515,
            "key.offset" : 515,
            "key.parsed_declaration" : "public init<S: Sequence>(_ sequence: S)\n  where S.Iterator.Element == Element",
            "key.parsed_scope.end" : 20,
            "key.parsed_scope.start" : 15,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC12arrayLiteralACyxGxd_tcfc\">init(arrayLiteral:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 8,
                    "key.offset" : 523
                  }
                ],
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>S<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "Sequence"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 11,
                "key.name" : "S",
                "key.namelength" : 1,
                "key.nameoffset" : 520,
                "key.offset" : 520,
                "key.parsed_declaration" : "public init<S: Sequence",
                "key.parsed_scope.end" : 15,
                "key.parsed_scope.start" : 15,
                "key.typename" : "S.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc1SL_qd__mfp"
              }
            ],
            "key.typename" : "<Element, S where Element : Equatable, Element == S.Element, S : Sequence> (ReferenceArray<Element>.Type) -> (S) -> ReferenceArray<Element>",
            "key.typeusr" : "$sy3PwZ14ReferenceArrayCyxGqd__c7ElementQyd__RszSTRd__luD",
            "key.usr" : "s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public required convenience init(arrayLiteral elements: <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>...)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.convenience",
                "key.length" : 11,
                "key.offset" : 1071
              },
              {
                "key.attribute" : "source.decl.attribute.required",
                "key.length" : 8,
                "key.offset" : 1062
              },
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1055
              }
            ],
            "key.bodylength" : 33,
            "key.bodyoffset" : 1124,
            "key.doc.column" : 33,
            "key.doc.comment" : "Initializes the array from an array literal. This means that you can write\ncode such as:\n\n    let ref: ReferenceArray<Int> = [0, 1, 2]\n\nAlternatively, type inference can remove the need to write the reference\narray's type at call sites:\n\n    func foo(_ ref: ReferenceArray<Int>) {\n        ...\n    }\n\n    foo([2, 4, 8])",
            "key.doc.declaration" : "public required convenience init(arrayLiteral elements: Element...)",
            "key.doc.discussion" : [
              {
                "CodeListing" : ""
              },
              {
                "Para" : "Alternatively, type inference can remove the need to write the reference array’s type at call sites:"
              },
              {
                "CodeListing" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"37\" column=\"33\"><Name>init(arrayLiteral:)<\/Name><USR>s:3PwZ14ReferenceArrayC12arrayLiteralACyxGxd_tcfc<\/USR><Declaration>public required convenience init(arrayLiteral elements: Element...)<\/Declaration><CommentParts><Abstract><Para>Initializes the array from an array literal. This means that you can write code such as:<\/Para><\/Abstract><Discussion><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let ref: ReferenceArray<Int> = [0, 1, 2]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Alternatively, type inference can remove the need to write the reference array’s type at call sites:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[func foo(_ ref: ReferenceArray<Int>) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    ...]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[foo([2, 4, 8])]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><\/Discussion><\/CommentParts><\/Function>",
            "key.doc.line" : 37,
            "key.doc.name" : "init(arrayLiteral:)",
            "key.doc.type" : "Function",
            "key.doclength" : 375,
            "key.docoffset" : 675,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>required<\/syntaxtype.keyword> <syntaxtype.keyword>convenience<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>arrayLiteral<\/decl.var.parameter.argument_label> <decl.var.parameter.name>elements<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param><\/decl.var.parameter.type>...<\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 75,
            "key.name" : "init(arrayLiteral:)",
            "key.namelength" : 39,
            "key.nameoffset" : 1083,
            "key.offset" : 1083,
            "key.overrides" : [
              {
                "key.usr" : "s:s25ExpressibleByArrayLiteralP05arrayD0x0cD7ElementQzd_tcfc"
              }
            ],
            "key.parsed_declaration" : "public required convenience init(arrayLiteral elements: Element...)",
            "key.parsed_scope.end" : 39,
            "key.parsed_scope.start" : 37,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayCyACyxGqd__c7ElementQyd__RszSTRd__lufc\">init(_:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>.Type) -> (Element...) -> ReferenceArray<Element>",
            "key.typeusr" : "$s12arrayLiteral3PwZ14ReferenceArrayCyxGxd_tcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC12arrayLiteralACyxGxd_tcfc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func append(_ element: <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1225
              }
            ],
            "key.bodylength" : 35,
            "key.bodyoffset" : 1265,
            "key.doc.column" : 17,
            "key.doc.comment" : "Adds a new element to the array at the end position.",
            "key.doc.declaration" : "public func append(_ element: Element)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"42\" column=\"17\"><Name>append(_:)<\/Name><USR>s:3PwZ14ReferenceArrayC6appendyyxF<\/USR><Declaration>public func append(_ element: Element)<\/Declaration><CommentParts><Abstract><Para>Adds a new element to the array at the end position.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 42,
            "key.doc.name" : "append(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 57,
            "key.docoffset" : 1164,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>append<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>element<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 69,
            "key.name" : "append(_:)",
            "key.namelength" : 26,
            "key.nameoffset" : 1237,
            "key.offset" : 1232,
            "key.parsed_declaration" : "public func append(_ element: Element)",
            "key.parsed_scope.end" : 44,
            "key.parsed_scope.start" : 42,
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>) -> (Element) -> ()",
            "key.typeusr" : "$syyxcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC6appendyyxF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func insert(_ element: <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>, at position: <Type usr=\"s:Si\">Int<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1371
              }
            ],
            "key.bodylength" : 49,
            "key.bodyoffset" : 1429,
            "key.doc.column" : 17,
            "key.doc.comment" : "Adds a new element to the array at a specific position.",
            "key.doc.declaration" : "public func insert(_ element: Element, at position: Int)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"47\" column=\"17\"><Name>insert(_:at:)<\/Name><USR>s:3PwZ14ReferenceArrayC6insert_2atyx_SitF<\/USR><Declaration>public func insert(_ element: Element, at position: Int)<\/Declaration><CommentParts><Abstract><Para>Adds a new element to the array at a specific position.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 47,
            "key.doc.name" : "insert(_:at:)",
            "key.doc.type" : "Function",
            "key.doclength" : 60,
            "key.docoffset" : 1307,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>insert<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>element<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>at<\/decl.var.parameter.argument_label> <decl.var.parameter.name>position<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 101,
            "key.name" : "insert(_:at:)",
            "key.namelength" : 44,
            "key.nameoffset" : 1383,
            "key.offset" : 1378,
            "key.parsed_declaration" : "public func insert(_ element: Element, at position: Int)",
            "key.parsed_scope.end" : 49,
            "key.parsed_scope.start" : 47,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC6insertyyxF\">insert(_:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>) -> (Element, Int) -> ()",
            "key.typeusr" : "$s_2atyx_SitcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC6insert_2atyx_SitF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func insert(_ element: <Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1548
              }
            ],
            "key.bodylength" : 36,
            "key.bodyoffset" : 1588,
            "key.doc.column" : 17,
            "key.doc.comment" : "Adds a new element to the array at the start position.",
            "key.doc.declaration" : "public func insert(_ element: Element)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"52\" column=\"17\"><Name>insert(_:)<\/Name><USR>s:3PwZ14ReferenceArrayC6insertyyxF<\/USR><Declaration>public func insert(_ element: Element)<\/Declaration><CommentParts><Abstract><Para>Adds a new element to the array at the start position.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 52,
            "key.doc.name" : "insert(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 59,
            "key.docoffset" : 1485,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>insert<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label> <decl.var.parameter.name>element<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 70,
            "key.name" : "insert(_:)",
            "key.namelength" : 26,
            "key.nameoffset" : 1560,
            "key.offset" : 1555,
            "key.parsed_declaration" : "public func insert(_ element: Element)",
            "key.parsed_scope.end" : 54,
            "key.parsed_scope.start" : 52,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC6insert_2atyx_SitF\">insert(_:at:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>) -> (Element) -> ()",
            "key.typeusr" : "$syyxcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC6insertyyxF"
          }
        ],
        "key.typename" : "ReferenceArray<Element>.Type",
        "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGmD",
        "key.usr" : "s:3PwZ14ReferenceArrayC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public class ReferenceArray&lt;Element&gt; : <Type usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/Type> where Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.bodylength" : 395,
        "key.bodyoffset" : 1665,
        "key.doc.column" : 14,
        "key.doc.declaration" : "public class ReferenceArray<Element> : ExpressibleByArrayLiteral where Element : Equatable",
        "key.doc.discussion" : [
          {
            "Para" : "Only the necessary methods are implemented."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"7\" column=\"14\"><Name>ReferenceArray<\/Name><USR>s:3PwZ14ReferenceArrayC<\/USR><Declaration>public class ReferenceArray&lt;Element&gt; : ExpressibleByArrayLiteral where Element : Equatable<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ReferenceArray<\/codeVoice> is a wrapper around the standard <codeVoice>Array<\/codeVoice> that provides reference semantics for mutable array objects.<\/Para><\/Abstract><Discussion><Para>Only the necessary methods are implemented.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 7,
        "key.doc.name" : "ReferenceArray",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 8,
            "key.offset" : 1655
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ReferenceArray<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Sequence"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 432,
        "key.name" : "ReferenceArray",
        "key.namelength" : 14,
        "key.nameoffset" : 1639,
        "key.offset" : 1629,
        "key.parsed_declaration" : "extension ReferenceArray: Sequence",
        "key.parsed_scope.end" : 70,
        "key.parsed_scope.start" : 57,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public typealias Iterator = <Type usr=\"s:s11AnyIteratorV\">AnyIterator<\/Type>&lt;<Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>&gt;<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1727
              }
            ],
            "key.doc.column" : 22,
            "key.doc.comment" : "Iterators over the `ReferenceArray` are generic.",
            "key.doc.declaration" : "public typealias Iterator = AnyIterator<Element>",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"59\" column=\"22\"><Name>Iterator<\/Name><USR>s:3PwZ14ReferenceArrayC8Iteratora<\/USR><Declaration>public typealias Iterator = AnyIterator&lt;Element&gt;<\/Declaration><CommentParts><Abstract><Para>Iterators over the <codeVoice>ReferenceArray<\/codeVoice> are generic.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 59,
            "key.doc.name" : "Iterator",
            "key.doc.type" : "Other",
            "key.doclength" : 53,
            "key.docoffset" : 1670,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Iterator<\/decl.name> = <ref.struct usr=\"s:s11AnyIteratorV\">AnyIterator<\/ref.struct>&lt;<ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.typealias>",
            "key.kind" : "source.lang.swift.decl.typealias",
            "key.length" : 41,
            "key.name" : "Iterator",
            "key.namelength" : 8,
            "key.nameoffset" : 1744,
            "key.offset" : 1734,
            "key.overrides" : [
              {
                "key.usr" : "s:ST8IteratorQa"
              },
              {
                "key.usr" : "s:Sl8IteratorQa"
              }
            ],
            "key.parsed_declaration" : "public typealias Iterator = AnyIterator<Element>",
            "key.parsed_scope.end" : 59,
            "key.parsed_scope.start" : 59,
            "key.typename" : "AnyIterator<Element>.Type",
            "key.typeusr" : "$ss11AnyIteratorVyxGmD",
            "key.usr" : "s:3PwZ14ReferenceArrayC8Iteratora"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func makeIterator() -&gt; <Type usr=\"s:3PwZ14ReferenceArrayC8Iteratora\">Iterator<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1894
              }
            ],
            "key.bodylength" : 124,
            "key.bodyoffset" : 1934,
            "key.doc.column" : 17,
            "key.doc.comment" : "Creates a new iterator for the `ReferenceArray`, wrapped as an\n`AnyIterator` to keep it generic.",
            "key.doc.declaration" : "public func makeIterator() -> Iterator",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"63\" column=\"17\"><Name>makeIterator()<\/Name><USR>s:3PwZ14ReferenceArrayC12makeIterators03AnyE0VyxGyF<\/USR><Declaration>public func makeIterator() -&gt; Iterator<\/Declaration><CommentParts><Abstract><Para>Creates a new iterator for the <codeVoice>ReferenceArray<\/codeVoice>, wrapped as an <codeVoice>AnyIterator<\/codeVoice> to keep it generic.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 63,
            "key.doc.name" : "makeIterator()",
            "key.doc.type" : "Function",
            "key.doclength" : 109,
            "key.docoffset" : 1781,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>makeIterator<\/decl.name>() -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ14ReferenceArrayC8Iteratora\">Iterator<\/ref.typealias><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 158,
            "key.name" : "makeIterator()",
            "key.namelength" : 14,
            "key.nameoffset" : 1906,
            "key.offset" : 1901,
            "key.overrides" : [
              {
                "key.usr" : "s:ST12makeIterator0B0QzyF"
              },
              {
                "key.usr" : "s:Sl12makeIterator0B0QzyF"
              }
            ],
            "key.parsed_declaration" : "public func makeIterator() -> Iterator",
            "key.parsed_scope.end" : 69,
            "key.parsed_scope.start" : 63,
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>var iterator: <Type usr=\"s:s16IndexingIteratorV\">IndexingIterator<\/Type>&lt;[Element]&gt;<\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>iterator<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s16IndexingIteratorV\">IndexingIterator<\/ref.struct>&lt;[Element]&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 35,
                "key.name" : "iterator",
                "key.namelength" : 8,
                "key.nameoffset" : 1947,
                "key.offset" : 1943,
                "key.parsed_declaration" : "var iterator = items.makeIterator()",
                "key.parsed_scope.end" : 64,
                "key.parsed_scope.start" : 64,
                "key.typename" : "IndexingIterator<[Element]>",
                "key.typeusr" : "$ss16IndexingIteratorVySayxGGD",
                "key.usr" : "s:3PwZ14ReferenceArrayC12makeIterators03AnyE0VyxGyF8iteratorL_s08IndexingE0VySayxGGvp"
              }
            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>) -> () -> AnyIterator<Element>",
            "key.typeusr" : "$ss11AnyIteratorVyxGycD",
            "key.usr" : "s:3PwZ14ReferenceArrayC12makeIterators03AnyE0VyxGyF"
          }
        ],
        "key.typename" : "ReferenceArray<Element>.Type",
        "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGmD",
        "key.usr" : "s:3PwZ14ReferenceArrayC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public class ReferenceArray&lt;Element&gt; : <Type usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/Type> where Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.bodylength" : 827,
        "key.bodyoffset" : 2101,
        "key.doc.column" : 14,
        "key.doc.declaration" : "public class ReferenceArray<Element> : ExpressibleByArrayLiteral where Element : Equatable",
        "key.doc.discussion" : [
          {
            "Para" : "Only the necessary methods are implemented."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"7\" column=\"14\"><Name>ReferenceArray<\/Name><USR>s:3PwZ14ReferenceArrayC<\/USR><Declaration>public class ReferenceArray&lt;Element&gt; : ExpressibleByArrayLiteral where Element : Equatable<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ReferenceArray<\/codeVoice> is a wrapper around the standard <codeVoice>Array<\/codeVoice> that provides reference semantics for mutable array objects.<\/Para><\/Abstract><Discussion><Para>Only the necessary methods are implemented.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 7,
        "key.doc.name" : "ReferenceArray",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 10,
            "key.offset" : 2089
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ReferenceArray<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Collection"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 866,
        "key.name" : "ReferenceArray",
        "key.namelength" : 14,
        "key.nameoffset" : 2073,
        "key.offset" : 2063,
        "key.parsed_declaration" : "extension ReferenceArray: Collection",
        "key.parsed_scope.end" : 102,
        "key.parsed_scope.start" : 72,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public typealias Index = <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2161
              }
            ],
            "key.doc.column" : 22,
            "key.doc.comment" : "The type of indices into the `ReferenceArray`.",
            "key.doc.declaration" : "public typealias Index = Int",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"74\" column=\"22\"><Name>Index<\/Name><USR>s:3PwZ14ReferenceArrayC5Indexa<\/USR><Declaration>public typealias Index = Int<\/Declaration><CommentParts><Abstract><Para>The type of indices into the <codeVoice>ReferenceArray<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 74,
            "key.doc.name" : "Index",
            "key.doc.type" : "Other",
            "key.doclength" : 51,
            "key.docoffset" : 2106,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Index<\/decl.name> = <ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.typealias>",
            "key.kind" : "source.lang.swift.decl.typealias",
            "key.length" : 21,
            "key.name" : "Index",
            "key.namelength" : 5,
            "key.nameoffset" : 2178,
            "key.offset" : 2168,
            "key.overrides" : [
              {
                "key.usr" : "s:Sl5IndexQa"
              }
            ],
            "key.parsed_declaration" : "public typealias Index = Int",
            "key.parsed_scope.end" : 74,
            "key.parsed_scope.start" : 74,
            "key.typename" : "Int.Type",
            "key.typeusr" : "$sSimD",
            "key.usr" : "s:3PwZ14ReferenceArrayC5Indexa"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var startIndex: <Type usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2238
              }
            ],
            "key.bodylength" : 37,
            "key.bodyoffset" : 2268,
            "key.doc.column" : 16,
            "key.doc.comment" : "The start index of the collection.",
            "key.doc.declaration" : "public var startIndex: Index { get }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"77\" column=\"16\"><Name>startIndex<\/Name><USR>s:3PwZ14ReferenceArrayC10startIndexSivp<\/USR><Declaration>public var startIndex: Index { get }<\/Declaration><CommentParts><Abstract><Para>The start index of the collection.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 77,
            "key.doc.name" : "startIndex",
            "key.doc.type" : "Other",
            "key.doclength" : 39,
            "key.docoffset" : 2195,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>startIndex<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/ref.typealias><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 61,
            "key.name" : "startIndex",
            "key.namelength" : 10,
            "key.nameoffset" : 2249,
            "key.offset" : 2245,
            "key.overrides" : [
              {
                "key.usr" : "s:Sl10startIndex0B0Qzvp"
              }
            ],
            "key.parsed_declaration" : "public var startIndex: Index",
            "key.parsed_scope.end" : 79,
            "key.parsed_scope.start" : 77,
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ14ReferenceArrayC10startIndexSivp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var endIndex: <Type usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2353
              }
            ],
            "key.bodylength" : 35,
            "key.bodyoffset" : 2381,
            "key.doc.column" : 16,
            "key.doc.comment" : "The end index of the collection.",
            "key.doc.declaration" : "public var endIndex: Index { get }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"82\" column=\"16\"><Name>endIndex<\/Name><USR>s:3PwZ14ReferenceArrayC8endIndexSivp<\/USR><Declaration>public var endIndex: Index { get }<\/Declaration><CommentParts><Abstract><Para>The end index of the collection.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 82,
            "key.doc.name" : "endIndex",
            "key.doc.type" : "Other",
            "key.doclength" : 37,
            "key.docoffset" : 2312,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>endIndex<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/ref.typealias><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 57,
            "key.name" : "endIndex",
            "key.namelength" : 8,
            "key.nameoffset" : 2364,
            "key.offset" : 2360,
            "key.overrides" : [
              {
                "key.usr" : "s:Sl8endIndex0B0Qzvp"
              }
            ],
            "key.parsed_declaration" : "public var endIndex: Index",
            "key.parsed_scope.end" : 84,
            "key.parsed_scope.start" : 82,
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ14ReferenceArrayC8endIndexSivp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public subscript(position: <Type usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/Type>) -&gt; <Type usr=\"s:3PwZ14ReferenceArrayC8Iteratora\">Iterator<\/Type>.<Type usr=\"s:s11AnyIteratorV7Elementa\">Element<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2582
              }
            ],
            "key.bodylength" : 150,
            "key.bodyoffset" : 2637,
            "key.doc.column" : 12,
            "key.doc.comment" : "`ReferenceArray`s can be accessed by subscript, e.g.:\n\n    let ref: ReferenceArray<Int> = [1, 2, 3]\n    let firstValue = ref[0]",
            "key.doc.declaration" : "public subscript(position: Index) -> Iterator.Element { get }",
            "key.doc.discussion" : [
              {
                "CodeListing" : ""
              }
            ],
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"92\" column=\"12\"><Name>subscript(_:)<\/Name><USR>s:3PwZ14ReferenceArrayCyxSicip<\/USR><Declaration>public subscript(position: Index) -&gt; Iterator.Element { get }<\/Declaration><CommentParts><Abstract><Para><codeVoice>ReferenceArray<\/codeVoice>s can be accessed by subscript, e.g.:<\/Para><\/Abstract><Discussion><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let ref: ReferenceArray<Int> = [1, 2, 3]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[let firstValue = ref[0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><\/Discussion><\/CommentParts><\/Other>",
            "key.doc.line" : 92,
            "key.doc.name" : "subscript(_:)",
            "key.doc.type" : "Other",
            "key.doclength" : 154,
            "key.docoffset" : 2423,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.subscript><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>subscript<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.name>position<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ14ReferenceArrayC8Iteratora\">Iterator<\/ref.typealias>.<ref.typealias usr=\"s:s11AnyIteratorV7Elementa\">Element<\/ref.typealias><\/decl.function.returntype> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.function.subscript>",
            "key.kind" : "source.lang.swift.decl.function.subscript",
            "key.length" : 199,
            "key.name" : "subscript(_:)",
            "key.namelength" : 26,
            "key.nameoffset" : 2589,
            "key.offset" : 2589,
            "key.overrides" : [
              {
                "key.usr" : "s:Sly7ElementQz5IndexQzcip"
              }
            ],
            "key.parsed_declaration" : "public subscript(position: Index) -> Iterator.Element",
            "key.parsed_scope.end" : 96,
            "key.parsed_scope.start" : 92,
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (Int) -> Element",
            "key.typeusr" : "$syxSicD",
            "key.usr" : "s:3PwZ14ReferenceArrayCyxSicip"
          },
          {
            "key.annotated_decl" : "<Declaration>let element: Element<\/Declaration>",
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>element<\/decl.name>: <decl.var.type>Element<\/decl.var.type><\/decl.var.local>",
            "key.kind" : "source.lang.swift.decl.var.local",
            "key.length" : 29,
            "key.name" : "element",
            "key.namelength" : 7,
            "key.nameoffset" : 2734,
            "key.offset" : 2730,
            "key.parsed_declaration" : "let element = items[position]",
            "key.parsed_scope.end" : 94,
            "key.parsed_scope.start" : 94,
            "key.typename" : "Element",
            "key.typeusr" : "$sxD",
            "key.usr" : "s:3PwZ14ReferenceArrayCyxSicig7elementL_xvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func index(after i: <Type usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/Type>) -&gt; <Type usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2856
              }
            ],
            "key.bodylength" : 26,
            "key.bodyoffset" : 2900,
            "key.doc.column" : 17,
            "key.doc.comment" : "Produces the index immediately after the given index.",
            "key.doc.declaration" : "public func index(after i: Index) -> Index",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"99\" column=\"17\"><Name>index(after:)<\/Name><USR>s:3PwZ14ReferenceArrayC5index5afterS2i_tF<\/USR><Declaration>public func index(after i: Index) -&gt; Index<\/Declaration><CommentParts><Abstract><Para>Produces the index immediately after the given index.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 99,
            "key.doc.name" : "index(after:)",
            "key.doc.type" : "Function",
            "key.doclength" : 58,
            "key.docoffset" : 2794,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>index<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>after<\/decl.var.parameter.argument_label> <decl.var.parameter.name>i<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ14ReferenceArrayC5Indexa\">Index<\/ref.typealias><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 64,
            "key.name" : "index(after:)",
            "key.namelength" : 21,
            "key.nameoffset" : 2868,
            "key.offset" : 2863,
            "key.overrides" : [
              {
                "key.usr" : "s:Sl5index5after5IndexQzAD_tF"
              }
            ],
            "key.parsed_declaration" : "public func index(after i: Index) -> Index",
            "key.parsed_scope.end" : 101,
            "key.parsed_scope.start" : 99,
            "key.substructure" : [

            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>) -> (Int) -> Int",
            "key.typeusr" : "$s5afterS2i_tcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC5index5afterS2i_tF"
          }
        ],
        "key.typename" : "ReferenceArray<Element>.Type",
        "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGmD",
        "key.usr" : "s:3PwZ14ReferenceArrayC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public class ReferenceArray&lt;Element&gt; : <Type usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/Type> where Element : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.bodylength" : 259,
        "key.bodyoffset" : 2993,
        "key.doc.column" : 14,
        "key.doc.declaration" : "public class ReferenceArray<Element> : ExpressibleByArrayLiteral where Element : Equatable",
        "key.doc.discussion" : [
          {
            "Para" : "Only the necessary methods are implemented."
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"7\" column=\"14\"><Name>ReferenceArray<\/Name><USR>s:3PwZ14ReferenceArrayC<\/USR><Declaration>public class ReferenceArray&lt;Element&gt; : ExpressibleByArrayLiteral where Element : Equatable<\/Declaration><CommentParts><Abstract><Para>The <codeVoice>ReferenceArray<\/codeVoice> is a wrapper around the standard <codeVoice>Array<\/codeVoice> that provides reference semantics for mutable array objects.<\/Para><\/Abstract><Discussion><Para>Only the necessary methods are implemented.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.line" : 7,
        "key.doc.name" : "ReferenceArray",
        "key.doc.type" : "Class",
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 2957
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>ReferenceArray<\/decl.name>&lt;<decl.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : <ref.protocol usr=\"s:s25ExpressibleByArrayLiteralP\">ExpressibleByArrayLiteral<\/ref.protocol> <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.generic_type_requirement><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Equatable"
          }
        ],
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 322,
        "key.name" : "ReferenceArray",
        "key.namelength" : 14,
        "key.nameoffset" : 2941,
        "key.offset" : 2931,
        "key.parsed_declaration" : "extension ReferenceArray: Equatable where Element: Equatable",
        "key.parsed_scope.end" : 110,
        "key.parsed_scope.start" : 104,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func == (lhs: <Type usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/Type>&lt;<Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>&gt;, rhs: <Type usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/Type>&lt;<Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>&gt;) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 3115
              }
            ],
            "key.bodylength" : 43,
            "key.bodyoffset" : 3207,
            "key.doc.column" : 24,
            "key.doc.comment" : "When the elements of a `ReferenceArray` are `Equatable`, the\n`ReferenceArray` itself is `Equatable`.",
            "key.doc.declaration" : "public static func == (lhs: ReferenceArray<Element>, rhs: ReferenceArray<Element>) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift\" line=\"107\" column=\"24\"><Name>==(_:_:)<\/Name><USR>s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ<\/USR><Declaration>public static func == (lhs: ReferenceArray&lt;Element&gt;, rhs: ReferenceArray&lt;Element&gt;) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para>When the elements of a <codeVoice>ReferenceArray<\/codeVoice> are <codeVoice>Equatable<\/codeVoice>, the <codeVoice>ReferenceArray<\/codeVoice> itself is <codeVoice>Equatable<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 107,
            "key.doc.name" : "==(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 113,
            "key.docoffset" : 2998,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>== <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/ref.class>&lt;<ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/ref.class>&lt;<ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 129,
            "key.name" : "==(_:_:)",
            "key.namelength" : 63,
            "key.nameoffset" : 3134,
            "key.offset" : 3122,
            "key.overrides" : [
              {
                "key.usr" : "s:SQ2eeoiySbx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func == (lhs: ReferenceArray<Element>, rhs: ReferenceArray<Element>) -> Bool",
            "key.parsed_scope.end" : 109,
            "key.parsed_scope.start" : 107,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ\">== (_: Expression, _: Expression) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ\">== (_: ExpressionCase, _: ExpressionCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ\">== (_: ContextCase, _: ContextCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ\">== (_: MemoizationRecord, _: MemoizationRecord) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbypXpSg_ABtF\">== (_: Any.Type?, _: Any.Type?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_xtSYRzSQ8RawValueRpzlF\">== &lt;T&gt;(_: T, _: T) -&gt; Bool where T : RawRepresentable, T.RawValue : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbyt_yttF\">== (_: (), _: ()) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_t_x_q_ttSQRzSQR_r0_lF\">== &lt;A, B&gt;(_: (A, B), _: (A, B)) -&gt; Bool where A : Equatable, B : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_t_x_q_q0_ttSQRzSQR_SQR0_r1_lF\">== &lt;A, B, C&gt;(_: (A, B, C), _: (A, B, C)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_t_x_q_q0_q1_ttSQRzSQR_SQR0_SQR1_r2_lF\">== &lt;A, B, C, D&gt;(_: (A, B, C, D), _: (A, B, C, D)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_t_x_q_q0_q1_q2_ttSQRzSQR_SQR0_SQR1_SQR2_r3_lF\">== &lt;A, B, C, D, E&gt;(_: (A, B, C, D, E), _: (A, B, C, D, E)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_q3_t_x_q_q0_q1_q2_q3_ttSQRzSQR_SQR0_SQR1_SQR2_SQR3_r4_lF\">== &lt;A, B, C, D, E, F&gt;(_: (A, B, C, D, E, F), _: (A, B, C, D, E, F)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SasSQRzlE2eeoiySbSayxG_ABtFZ\">== (_: Array&lt;Element&gt;, _: Array&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10ArraySliceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ArraySlice&lt;Element&gt;, _: ArraySlice&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sb2eeoiyS2b_SbtFZ\">== (_: Bool, _: Bool) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SJ2eeoiySbSJ_SJtFZ\">== (_: Character, _: Character) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17CodingUserInfoKeyV2eeoiySbAB_ABtFZ\">== (_: CodingUserInfoKey, _: CodingUserInfoKey) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15ContiguousArrayVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ContiguousArray&lt;Element&gt;, _: ContiguousArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SNsSxRzSZ6StrideRpzrlE5IndexO2eeoiySbADyx_G_AFtFZ\">== (_: ClosedRange&lt;Bound&gt;.Index, _: ClosedRange&lt;Bound&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SN2eeoiySbSNyxG_ABtFZ\">== (_: ClosedRange&lt;Bound&gt;, _: ClosedRange&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s13OpaquePointerV2eeoiySbAB_ABtFZ\">== (_: OpaquePointer, _: OpaquePointer) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD4KeysV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Keys, _: Dictionary&lt;Key, Value&gt;.Keys) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SDsSQR_rlE2eeoiySbSDyxq_G_ABtFZ\">== (_: [Key : Value], _: [Key : Value]) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD5IndexV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Index, _: Dictionary&lt;Key, Value&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15EmptyCollectionV2eeoiySbAByxG_ADtFZ\">== (_: EmptyCollection&lt;Element&gt;, _: EmptyCollection&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SQ2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15FlattenSequenceVsSlRzSl7ElementRpzrlE5IndexV2eeoiySbAFyx_G_AHtFZ\">== (_: FlattenCollection&lt;Base&gt;.Index, _: FlattenCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17FloatingPointSignO2eeoiySbAB_ABtFZ\">== (_: FloatingPointSign, _: FloatingPointSign) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s27FloatingPointClassificationO2eeoiySbAB_ABtFZ\">== (_: FloatingPointClassification, _: FloatingPointClassification) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s25FloatingPointRoundingRuleO2eeoiySbAB_ABtFZ\">== (_: FloatingPointRoundingRule, _: FloatingPointRoundingRule) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SFsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11AnyHashableV2eeoiySbAB_ABtFZ\">== (_: AnyHashable, _: AnyHashable) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SzsE2eeoiySbx_qd__tSzRd__lFZ\">== &lt;Other&gt;(_: Self, _: Other) -&gt; Bool where Other : BinaryInteger<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V2eeoiySbAB_ABtFZ\">== (_: UInt8, _: UInt8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V2eeoiySbAB_ABtFZ\">== (_: Int8, _: Int8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V2eeoiySbAB_ABtFZ\">== (_: UInt16, _: UInt16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V2eeoiySbAB_ABtFZ\">== (_: Int16, _: Int16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V2eeoiySbAB_ABtFZ\">== (_: UInt32, _: UInt32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V2eeoiySbAB_ABtFZ\">== (_: Int32, _: Int32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V2eeoiySbAB_ABtFZ\">== (_: UInt64, _: UInt64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V2eeoiySbAB_ABtFZ\">== (_: Int64, _: Int64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su2eeoiySbSu_SutFZ\">== (_: UInt, _: UInt) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si2eeoiySbSi_SitFZ\">== (_: Int, _: Int) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10AnyKeyPathC2eeoiySbAB_ABtFZ\">== (_: AnyKeyPath, _: AnyKeyPath) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20ManagedBufferPointerV2eeoiySbAByxq_G_ADtFZ\">== (_: ManagedBufferPointer&lt;Header, Element&gt;, _: ManagedBufferPointer&lt;Header, Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO6ScalarV2eeoiySbAD_ADtFZ\">== (_: Unicode.Scalar, _: Unicode.Scalar) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SO2eeoiySbSO_SOtFZ\">== (_: ObjectIdentifier, _: ObjectIdentifier) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SqsSQRzlE2eeoiySbxSg_ABtFZ\">== (_: Wrapped?, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbxSg_s26_OptionalNilComparisonTypeVtFZ\">== (_: Wrapped?, _: _OptionalNilComparisonType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbs26_OptionalNilComparisonTypeV_xSgtFZ\">== (_: _OptionalNilComparisonType, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8_PointerPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5NeverO2eeoiySbAB_ABtFZ\">== (_: Never, _: Never) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s23LazyPrefixWhileSequenceVsSlRzrlE5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: LazyPrefixWhileCollection&lt;Base&gt;.Index, _: LazyPrefixWhileCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sn2eeoiySbSnyxG_ABtFZ\">== (_: Range&lt;Bound&gt;, _: Range&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6ResultOsSQRzSQR_rlE2eeoiySbAByxq_G_ADtFZ\">== (_: Result&lt;Success, Failure&gt;, _: Result&lt;Success, Failure&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s18ReversedCollectionV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: ReversedCollection&lt;Base&gt;.Index, _: ReversedCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh2eeoiySbShyxG_ABtFZ\">== (_: Set&lt;Element&gt;, _: Set&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh5IndexV2eeoiySbAByx_G_ADtFZ\">== (_: Set&lt;Element&gt;.Index, _: Set&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SxsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SysE2eeoiySbx_qd__tSyRd__lFZ\">== &lt;RHS&gt;(_: Self, _: RHS) -&gt; Bool where RHS : StringProtocol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS2eeoiySbSS_SStFZ\">== (_: String, _: String) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS5IndexV2eeoiySbAB_ABtFZ\">== (_: String.Index, _: String.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11_UIntBufferV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: _UIntBuffer&lt;Element&gt;.Index, _: _UIntBuffer&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO15GeneralCategoryO2eeoiySbAD_ADtFZ\">== (_: Unicode.GeneralCategory, _: Unicode.GeneralCategory) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO23CanonicalCombiningClassV2eeoiySbAD_ADtFZ\">== (_: Unicode.CanonicalCombiningClass, _: Unicode.CanonicalCombiningClass) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO11NumericTypeO2eeoiySbAD_ADtFZ\">== (_: Unicode.NumericType, _: Unicode.NumericType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO5UTF32O2eeoiySbAD_ADtFZ\">== (_: Unicode.UTF32, _: Unicode.UTF32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s21UnicodeDecodingResultO2eeoiySbAB_ABtFZ\">== (_: UnicodeDecodingResult, _: UnicodeDecodingResult) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s16_ValidUTF8BufferV5IndexV2eeoiySbAD_ADtFZ\">== (_: _ValidUTF8Buffer.Index, _: _ValidUTF8Buffer.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Index, _: CollectionDifference&lt;ChangeElement&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV6ChangeOsSQRzlE2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Change, _: CollectionDifference&lt;ChangeElement&gt;.Change) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;, _: CollectionDifference&lt;ChangeElement&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8AnyIndexV2eeoiySbAB_ABtFZ\">== (_: AnyIndex, _: AnyIndex) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6MirrorV12DisplayStyleO2eeoiySbAD_ADtFZ\">== (_: Mirror.DisplayStyle, _: Mirror.DisplayStyle) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4SIMDPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/Type>&lt;<Type usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/Type>&gt;<\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/ReferenceArray.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/ref.class>&lt;<ref.generic_type_param usr=\"s:3PwZ14ReferenceArrayC7Elementxmfp\">Element<\/ref.generic_type_param>&gt;<\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 3138,
                "key.parent_loc" : 3134,
                "key.parsed_declaration" : "public static func == (lhs",
                "key.parsed_scope.end" : 107,
                "key.parsed_scope.start" : 107,
                "key.typename" : "ReferenceArray<Element>",
                "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGD",
                "key.usr" : "s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ3lhsL_AEvp"
              }
            ],
            "key.typename" : "<Element where Element : Equatable> (ReferenceArray<Element>.Type) -> (ReferenceArray<Element>, ReferenceArray<Element>) -> Bool",
            "key.typeusr" : "$sySb3PwZ14ReferenceArrayCyxG_ADtcD",
            "key.usr" : "s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ"
          }
        ],
        "key.typename" : "ReferenceArray<Element>.Type",
        "key.typeusr" : "$s3PwZ14ReferenceArrayCyxGmD",
        "key.usr" : "s:3PwZ14ReferenceArrayC"
      }
    ]
  }
}, {
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 3055,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public struct SentinelStruct<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 198
          }
        ],
        "key.bodylength" : 1824,
        "key.bodyoffset" : 228,
        "key.doc.column" : 15,
        "key.doc.comment" : "The SentinelStruct exists only to produce a singleton from which sentinel\nvalues for various parsing-related types can be drawn. See the documentation\nfor the `Sentinel` singleton value.",
        "key.doc.declaration" : "public struct SentinelStruct",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"6\" column=\"15\"><Name>SentinelStruct<\/Name><USR>s:3PwZ14SentinelStructV<\/USR><Declaration>public struct SentinelStruct<\/Declaration><CommentParts><Abstract><Para>The SentinelStruct exists only to produce a singleton from which sentinel values for various parsing-related types can be drawn. See the documentation for the <codeVoice>Sentinel<\/codeVoice> singleton value.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 6,
        "key.doc.name" : "SentinelStruct",
        "key.doc.type" : "Class",
        "key.doclength" : 197,
        "key.docoffset" : 0,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>SentinelStruct<\/decl.name><\/decl.struct>",
        "key.kind" : "source.lang.swift.decl.struct",
        "key.length" : 1848,
        "key.name" : "SentinelStruct",
        "key.namelength" : 14,
        "key.nameoffset" : 212,
        "key.offset" : 205,
        "key.parsed_declaration" : "public struct SentinelStruct",
        "key.parsed_scope.end" : 44,
        "key.parsed_scope.start" : 6,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate let integer: <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 233
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>integer<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 21,
            "key.name" : "integer",
            "key.namelength" : 7,
            "key.nameoffset" : 249,
            "key.offset" : 245,
            "key.parsed_declaration" : "fileprivate let integer: Int = -1",
            "key.parsed_scope.end" : 7,
            "key.parsed_scope.start" : 7,
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ14SentinelStructV7integer33_0C360417EE50CB15238E067957B37AE9LLSivp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate let symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 318
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>symbol<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 33,
            "key.name" : "symbol",
            "key.namelength" : 6,
            "key.nameoffset" : 334,
            "key.offset" : 330,
            "key.parsed_declaration" : "fileprivate let symbol: Symbol = \"<s_bottom>\"",
            "key.parsed_scope.end" : 8,
            "key.parsed_scope.start" : 8,
            "key.typename" : "String",
            "key.typeusr" : "$sSSD",
            "key.usr" : "s:3PwZ14SentinelStructV6symbol33_0C360417EE50CB15238E067957B37AE9LLSSvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate let token: <Type usr=\"s:3PwZ5Tokena\">Token<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 368
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>token<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 34,
            "key.name" : "token",
            "key.namelength" : 5,
            "key.nameoffset" : 384,
            "key.offset" : 380,
            "key.parsed_declaration" : "fileprivate let token: Token = (-1, \"<t_eof>\")",
            "key.parsed_scope.end" : 9,
            "key.parsed_scope.start" : 9,
            "key.typename" : "(tag: Int, symbol: String)",
            "key.typeusr" : "$sSi3tag_SS6symboltD",
            "key.usr" : "s:3PwZ14SentinelStructV5token33_0C360417EE50CB15238E067957B37AE9LLSi3tag_SS6symboltvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate let expression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 788
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>expression<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 26,
            "key.name" : "expression",
            "key.namelength" : 10,
            "key.nameoffset" : 804,
            "key.offset" : 800,
            "key.parsed_declaration" : "fileprivate let expression: Expression",
            "key.parsed_scope.end" : 17,
            "key.parsed_scope.start" : 17,
            "key.typename" : "Expression",
            "key.typeusr" : "$s3PwZ10ExpressionCD",
            "key.usr" : "s:3PwZ14SentinelStructV10expression33_0C360417EE50CB15238E067957B37AE9LLAA10ExpressionCvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate let memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 831
              }
            ],
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>memoizationRecord<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 40,
            "key.name" : "memoizationRecord",
            "key.namelength" : 17,
            "key.nameoffset" : 847,
            "key.offset" : 843,
            "key.parsed_declaration" : "fileprivate let memoizationRecord: MemoizationRecord",
            "key.parsed_scope.end" : 18,
            "key.parsed_scope.start" : 18,
            "key.typename" : "MemoizationRecord",
            "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
            "key.usr" : "s:3PwZ14SentinelStructV17memoizationRecord33_0C360417EE50CB15238E067957B37AE9LLAA011MemoizationE0Cvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.fileprivate",
            "key.annotated_decl" : "<Declaration>fileprivate init()<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.fileprivate",
                "key.length" : 11,
                "key.offset" : 889
              }
            ],
            "key.bodylength" : 530,
            "key.bodyoffset" : 909,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>fileprivate<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>()<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 539,
            "key.name" : "init()",
            "key.namelength" : 6,
            "key.nameoffset" : 901,
            "key.offset" : 901,
            "key.parsed_declaration" : "fileprivate init()",
            "key.parsed_scope.end" : 28,
            "key.parsed_scope.start" : 20,
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct.Type) -> () -> SentinelStruct",
            "key.typeusr" : "$s3PwZ14SentinelStructVycD",
            "key.usr" : "s:3PwZ14SentinelStructVACyc33_0C360417EE50CB15238E067957B37AE9Llfc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func of(_: <Type usr=\"s:Si\">Int<\/Type>.Type) -&gt; <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1492
              }
            ],
            "key.bodylength" : 21,
            "key.bodyoffset" : 1528,
            "key.doc.column" : 17,
            "key.doc.comment" : "Create a sentinel for any `Int` type.",
            "key.doc.declaration" : "public func of(_: Int.Type) -> Int",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"31\" column=\"17\"><Name>of(_:)<\/Name><USR>s:3PwZ14SentinelStructV2ofyS2imF<\/USR><Declaration>public func of(_: Int.Type) -&gt; Int<\/Declaration><CommentParts><Abstract><Para>Create a sentinel for any <codeVoice>Int<\/codeVoice> type.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 31,
            "key.doc.name" : "of(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 42,
            "key.docoffset" : 1446,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>of<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.struct usr=\"s:Si\">Int<\/ref.struct>.Type<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 51,
            "key.name" : "of(_:)",
            "key.namelength" : 15,
            "key.nameoffset" : 1504,
            "key.offset" : 1499,
            "key.parsed_declaration" : "public func of(_: Int.Type) -> Int",
            "key.parsed_scope.end" : 31,
            "key.parsed_scope.start" : 31,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2SmF\">of(_: Symbol.Type) -&gt; Symbol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF\">of(_: Token.Type) -&gt; Token<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF\">of(_: Expression.Type) -&gt; Expression<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF\">of(_: MemoizationRecord.Type) -&gt; MemoizationRecord<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct) -> (Int.Type) -> Int",
            "key.typeusr" : "$syS2imcD",
            "key.usr" : "s:3PwZ14SentinelStructV2ofyS2imF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func of(_: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>.Type) -&gt; <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1598
              }
            ],
            "key.bodylength" : 20,
            "key.bodyoffset" : 1640,
            "key.doc.column" : 17,
            "key.doc.comment" : "Create a sentinel for a `Symbol`.",
            "key.doc.declaration" : "public func of(_: Symbol.Type) -> Symbol",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"34\" column=\"17\"><Name>of(_:)<\/Name><USR>s:3PwZ14SentinelStructV2ofyS2SmF<\/USR><Declaration>public func of(_: Symbol.Type) -&gt; Symbol<\/Declaration><CommentParts><Abstract><Para>Create a sentinel for a <codeVoice>Symbol<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 34,
            "key.doc.name" : "of(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 38,
            "key.docoffset" : 1556,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>of<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias>.Type<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 56,
            "key.name" : "of(_:)",
            "key.namelength" : 18,
            "key.nameoffset" : 1610,
            "key.offset" : 1605,
            "key.parsed_declaration" : "public func of(_: Symbol.Type) -> Symbol",
            "key.parsed_scope.end" : 34,
            "key.parsed_scope.start" : 34,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2imF\">of(_: Int.Type) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF\">of(_: Token.Type) -&gt; Token<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF\">of(_: Expression.Type) -&gt; Expression<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF\">of(_: MemoizationRecord.Type) -&gt; MemoizationRecord<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct) -> (String.Type) -> String",
            "key.typeusr" : "$syS2SmcD",
            "key.usr" : "s:3PwZ14SentinelStructV2ofyS2SmF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func of(_: <Type usr=\"s:3PwZ5Tokena\">Token<\/Type>.Type) -&gt; <Type usr=\"s:3PwZ5Tokena\">Token<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1708
              }
            ],
            "key.bodylength" : 19,
            "key.bodyoffset" : 1748,
            "key.doc.column" : 17,
            "key.doc.comment" : "Create a sentinel for a `Token`.",
            "key.doc.declaration" : "public func of(_: Token.Type) -> Token",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"37\" column=\"17\"><Name>of(_:)<\/Name><USR>s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF<\/USR><Declaration>public func of(_: Token.Type) -&gt; Token<\/Declaration><CommentParts><Abstract><Para>Create a sentinel for a <codeVoice>Token<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 37,
            "key.doc.name" : "of(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 37,
            "key.docoffset" : 1667,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>of<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias>.Type<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 53,
            "key.name" : "of(_:)",
            "key.namelength" : 17,
            "key.nameoffset" : 1720,
            "key.offset" : 1715,
            "key.parsed_declaration" : "public func of(_: Token.Type) -> Token",
            "key.parsed_scope.end" : 37,
            "key.parsed_scope.start" : 37,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2imF\">of(_: Int.Type) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2SmF\">of(_: Symbol.Type) -&gt; Symbol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF\">of(_: Expression.Type) -&gt; Expression<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF\">of(_: MemoizationRecord.Type) -&gt; MemoizationRecord<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct) -> ((tag: Int, symbol: String).Type) -> (tag: Int, symbol: String)",
            "key.typeusr" : "$sySi3tag_SS6symboltSiAA_SSABtmcD",
            "key.usr" : "s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func of(_: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>.Type) -&gt; <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1821
              }
            ],
            "key.bodylength" : 24,
            "key.bodyoffset" : 1871,
            "key.doc.column" : 17,
            "key.doc.comment" : "Create a sentinel for an `Expression`.",
            "key.doc.declaration" : "public func of(_: Expression.Type) -> Expression",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"40\" column=\"17\"><Name>of(_:)<\/Name><USR>s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF<\/USR><Declaration>public func of(_: Expression.Type) -&gt; Expression<\/Declaration><CommentParts><Abstract><Para>Create a sentinel for an <codeVoice>Expression<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 40,
            "key.doc.name" : "of(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 43,
            "key.docoffset" : 1774,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>of<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>.Type<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 68,
            "key.name" : "of(_:)",
            "key.namelength" : 22,
            "key.nameoffset" : 1833,
            "key.offset" : 1828,
            "key.parsed_declaration" : "public func of(_: Expression.Type) -> Expression",
            "key.parsed_scope.end" : 40,
            "key.parsed_scope.start" : 40,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2imF\">of(_: Int.Type) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2SmF\">of(_: Symbol.Type) -&gt; Symbol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF\">of(_: Token.Type) -&gt; Token<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF\">of(_: MemoizationRecord.Type) -&gt; MemoizationRecord<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct) -> (Expression.Type) -> Expression",
            "key.typeusr" : "$sy3PwZ10ExpressionCACmcD",
            "key.usr" : "s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func of(_: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>.Type) -&gt; <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1955
              }
            ],
            "key.bodylength" : 31,
            "key.bodyoffset" : 2019,
            "key.doc.column" : 17,
            "key.doc.comment" : "Create a sentinel for a `MemoizationRecord`.",
            "key.doc.declaration" : "public func of(_: MemoizationRecord.Type) -> MemoizationRecord",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"43\" column=\"17\"><Name>of(_:)<\/Name><USR>s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF<\/USR><Declaration>public func of(_: MemoizationRecord.Type) -&gt; MemoizationRecord<\/Declaration><CommentParts><Abstract><Para>Create a sentinel for a <codeVoice>MemoizationRecord<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 43,
            "key.doc.name" : "of(_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 49,
            "key.docoffset" : 1902,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>of<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>_<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class>.Type<\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.function.returntype><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 89,
            "key.name" : "of(_:)",
            "key.namelength" : 29,
            "key.nameoffset" : 1967,
            "key.offset" : 1962,
            "key.parsed_declaration" : "public func of(_: MemoizationRecord.Type) -> MemoizationRecord",
            "key.parsed_scope.end" : 43,
            "key.parsed_scope.start" : 43,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2imF\">of(_: Int.Type) -&gt; Int<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyS2SmF\">of(_: Symbol.Type) -&gt; Symbol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofySi3tag_SS6symboltSiAE_SSAFtmF\">of(_: Token.Type) -&gt; Token<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14SentinelStructV2ofyAA10ExpressionCAFmF\">of(_: Expression.Type) -&gt; Expression<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(SentinelStruct) -> (MemoizationRecord.Type) -> MemoizationRecord",
            "key.typeusr" : "$sy3PwZ17MemoizationRecordCACmcD",
            "key.usr" : "s:3PwZ14SentinelStructV2ofyAA17MemoizationRecordCAFmF"
          }
        ],
        "key.typename" : "SentinelStruct.Type",
        "key.typeusr" : "$s3PwZ14SentinelStructVmD",
        "key.usr" : "s:3PwZ14SentinelStructV"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public let Sentinel: <Type usr=\"s:3PwZ14SentinelStructV\">SentinelStruct<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 2564
          }
        ],
        "key.doc.column" : 12,
        "key.doc.comment" : "The Sentinel singleton allows for using the sentinel values of any of the\nparsing-related types. To use it, you call the `of` method with the desired\ntype as an argument. For example, to get the sentinel for `Expression`s, do:\n\n    Sentinel.of(Expression.self)\n\nNote the use of `.self` on the type, which passes the type as a value directly.\nThe `Sentinel.of` method supports the following types:\n\n  - `Position`\n  - `Symbol`\n  - `Tag`\n  - `Token`\n  - `Expression`\n  - `MemoizationRecord`",
        "key.doc.declaration" : "public let Sentinel: PwZ.SentinelStruct",
        "key.doc.discussion" : [
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Note the use of `.self` on the type, which passes the type as a value directly. The `Sentinel.of` method supports the following types:"
          },
          {
            "List-Bullet" : ""
          }
        ],
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"63\" column=\"12\"><Name>Sentinel<\/Name><USR>s:3PwZ8SentinelAA0B6StructVvp<\/USR><Declaration>public let Sentinel: PwZ.SentinelStruct<\/Declaration><CommentParts><Abstract><Para>The Sentinel singleton allows for using the sentinel values of any of the parsing-related types. To use it, you call the <codeVoice>of<\/codeVoice> method with the desired type as an argument. For example, to get the sentinel for <codeVoice>Expression<\/codeVoice>s, do:<\/Para><\/Abstract><Discussion><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[Sentinel.of(Expression.self)]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>Note the use of <codeVoice>.self<\/codeVoice> on the type, which passes the type as a value directly. The <codeVoice>Sentinel.of<\/codeVoice> method supports the following types:<\/Para><List-Bullet><Item><Para><codeVoice>Position<\/codeVoice><\/Para><\/Item><Item><Para><codeVoice>Symbol<\/codeVoice><\/Para><\/Item><Item><Para><codeVoice>Tag<\/codeVoice><\/Para><\/Item><Item><Para><codeVoice>Token<\/codeVoice><\/Para><\/Item><Item><Para><codeVoice>Expression<\/codeVoice><\/Para><\/Item><Item><Para><codeVoice>MemoizationRecord<\/codeVoice><\/Para><\/Item><\/List-Bullet><\/Discussion><\/CommentParts><\/Other>",
        "key.doc.line" : 63,
        "key.doc.name" : "Sentinel",
        "key.doc.type" : "Other",
        "key.doclength" : 508,
        "key.docoffset" : 2055,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
        "key.fully_annotated_decl" : "<decl.var.global><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>Sentinel<\/decl.name>: <decl.var.type><ref.struct usr=\"s:3PwZ14SentinelStructV\">SentinelStruct<\/ref.struct><\/decl.var.type><\/decl.var.global>",
        "key.kind" : "source.lang.swift.decl.var.global",
        "key.length" : 31,
        "key.name" : "Sentinel",
        "key.namelength" : 8,
        "key.nameoffset" : 2575,
        "key.offset" : 2571,
        "key.parsed_declaration" : "public let Sentinel = SentinelStruct()",
        "key.parsed_scope.end" : 63,
        "key.parsed_scope.start" : 63,
        "key.typename" : "SentinelStruct",
        "key.typeusr" : "$s3PwZ14SentinelStructVD",
        "key.usr" : "s:3PwZ8SentinelAA0B6StructVvp"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.internal",
        "key.annotated_decl" : "<Declaration>public class Expression : <Type usr=\"s:SQ\">Equatable<\/Type>, <Type usr=\"s:s23CustomStringConvertibleP\">CustomStringConvertible<\/Type><\/Declaration>",
        "key.bodylength" : 339,
        "key.bodyoffset" : 2714,
        "key.doc.column" : 14,
        "key.doc.comment" : "Extend the `Expression` to be initializable with a default\n`MemoizationRecord`.",
        "key.doc.declaration" : "public class Expression : Equatable, CustomStringConvertible",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"30\" column=\"14\"><Name>Expression<\/Name><USR>s:3PwZ10ExpressionC<\/USR><Declaration>public class Expression : Equatable, CustomStringConvertible<\/Declaration><CommentParts><Abstract><Para>Expressions form trees in a grammar. We use a class instead of a struct to preserve reference semantics because grammars may have duplicate references to the same expression multiple times.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 30,
        "key.doc.name" : "Expression",
        "key.doc.type" : "Class",
        "key.doclength" : 88,
        "key.docoffset" : 2604,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>Expression<\/decl.name> : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol>, <ref.protocol usr=\"s:s23CustomStringConvertibleP\">CustomStringConvertible<\/ref.protocol><\/decl.class>",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 362,
        "key.name" : "Expression",
        "key.namelength" : 10,
        "key.nameoffset" : 2702,
        "key.offset" : 2692,
        "key.parsed_declaration" : "extension Expression",
        "key.parsed_scope.end" : 74,
        "key.parsed_scope.start" : 67,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public convenience init(expressionCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.convenience",
                "key.length" : 11,
                "key.offset" : 2872
              },
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2865
              }
            ],
            "key.bodylength" : 129,
            "key.bodyoffset" : 2922,
            "key.doc.column" : 24,
            "key.doc.comment" : "Initialize an `Expression` without needing to give an explicit\n`MemoizationRecord`. The record used is from the `Sentinel` value.",
            "key.doc.declaration" : "public convenience init(expressionCase: ExpressionCase)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift\" line=\"70\" column=\"24\"><Name>init(expressionCase:)<\/Name><USR>s:3PwZ10ExpressionC14expressionCaseAcA0bD0O_tcfc<\/USR><Declaration>public convenience init(expressionCase: ExpressionCase)<\/Declaration><CommentParts><Abstract><Para>Initialize an <codeVoice>Expression<\/codeVoice> without needing to give an explicit <codeVoice>MemoizationRecord<\/codeVoice>. The record used is from the <codeVoice>Sentinel<\/codeVoice> value.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 70,
            "key.doc.name" : "init(expressionCase:)",
            "key.doc.type" : "Function",
            "key.doclength" : 142,
            "key.docoffset" : 2719,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Sentinels.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>convenience<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>expressionCase<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 168,
            "key.name" : "init(expressionCase:)",
            "key.namelength" : 36,
            "key.nameoffset" : 2884,
            "key.offset" : 2884,
            "key.parsed_declaration" : "public convenience init(expressionCase: ExpressionCase)",
            "key.parsed_scope.end" : 73,
            "key.parsed_scope.start" : 70,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ10ExpressionC17memoizationRecord14expressionCaseAcA011MemoizationD0C_AA0bF0Otcfc\">init(memoizationRecord:expressionCase:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(Expression.Type) -> (ExpressionCase) -> Expression",
            "key.typeusr" : "$s14expressionCase3PwZ10ExpressionCAB0dB0O_tcD",
            "key.usr" : "s:3PwZ10ExpressionC14expressionCaseAcA0bD0O_tcfc"
          }
        ],
        "key.typename" : "Expression.Type",
        "key.typeusr" : "$s3PwZ10ExpressionCmD",
        "key.usr" : "s:3PwZ10ExpressionC"
      }
    ]
  }
}, {
  "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 6787,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public typealias Position = <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 141
          }
        ],
        "key.doc.column" : 18,
        "key.doc.comment" : "Positions are the indices of tokens within the input string being parsed.",
        "key.doc.declaration" : "public typealias Position = Int",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"7\" column=\"18\"><Name>Position<\/Name><USR>s:3PwZ8Positiona<\/USR><Declaration>public typealias Position = Int<\/Declaration><CommentParts><Abstract><Para>Positions are the indices of tokens within the input string being parsed.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 7,
        "key.doc.name" : "Position",
        "key.doc.type" : "Other",
        "key.doclength" : 78,
        "key.docoffset" : 63,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Position<\/decl.name> = <ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.typealias>",
        "key.kind" : "source.lang.swift.decl.typealias",
        "key.length" : 24,
        "key.name" : "Position",
        "key.namelength" : 8,
        "key.nameoffset" : 158,
        "key.offset" : 148,
        "key.parsed_declaration" : "public typealias Position = Int",
        "key.parsed_scope.end" : 7,
        "key.parsed_scope.start" : 7,
        "key.typename" : "Int.Type",
        "key.typeusr" : "$sSimD",
        "key.usr" : "s:3PwZ8Positiona"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public typealias Symbol = <Type usr=\"s:SS\">String<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 239
          }
        ],
        "key.doc.column" : 18,
        "key.doc.comment" : "Symbols are the names given to productions within a grammar.",
        "key.doc.declaration" : "public typealias Symbol = String",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"10\" column=\"18\"><Name>Symbol<\/Name><USR>s:3PwZ6Symbola<\/USR><Declaration>public typealias Symbol = String<\/Declaration><CommentParts><Abstract><Para>Symbols are the names given to productions within a grammar.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 10,
        "key.doc.name" : "Symbol",
        "key.doc.type" : "Other",
        "key.doclength" : 65,
        "key.docoffset" : 174,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Symbol<\/decl.name> = <ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.typealias>",
        "key.kind" : "source.lang.swift.decl.typealias",
        "key.length" : 25,
        "key.name" : "Symbol",
        "key.namelength" : 6,
        "key.nameoffset" : 256,
        "key.offset" : 246,
        "key.parsed_declaration" : "public typealias Symbol = String",
        "key.parsed_scope.end" : 10,
        "key.parsed_scope.start" : 10,
        "key.typename" : "String.Type",
        "key.typeusr" : "$sSSmD",
        "key.usr" : "s:3PwZ6Symbola"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public typealias Tag = <Type usr=\"s:Si\">Int<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 313
          }
        ],
        "key.doc.column" : 18,
        "key.doc.comment" : "Tags uniquely identify token types.",
        "key.doc.declaration" : "public typealias Tag = Int",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"13\" column=\"18\"><Name>Tag<\/Name><USR>s:3PwZ3Taga<\/USR><Declaration>public typealias Tag = Int<\/Declaration><CommentParts><Abstract><Para>Tags uniquely identify token types.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 13,
        "key.doc.name" : "Tag",
        "key.doc.type" : "Other",
        "key.doclength" : 40,
        "key.docoffset" : 273,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Tag<\/decl.name> = <ref.struct usr=\"s:Si\">Int<\/ref.struct><\/decl.typealias>",
        "key.kind" : "source.lang.swift.decl.typealias",
        "key.length" : 19,
        "key.name" : "Tag",
        "key.namelength" : 3,
        "key.nameoffset" : 330,
        "key.offset" : 320,
        "key.parsed_declaration" : "public typealias Tag = Int",
        "key.parsed_scope.end" : 13,
        "key.parsed_scope.start" : 13,
        "key.typename" : "Int.Type",
        "key.typeusr" : "$sSimD",
        "key.usr" : "s:3PwZ3Taga"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public typealias Token = (tag: <Type usr=\"s:3PwZ3Taga\">Tag<\/Type>, symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>)<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 464
          }
        ],
        "key.doc.column" : 18,
        "key.doc.comment" : "Tokens are pairs consisting of a tag (identifying the type of the token) and\na symbol (identify the token's text).",
        "key.doc.declaration" : "public typealias Token = (tag: Tag, symbol: Symbol)",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"17\" column=\"18\"><Name>Token<\/Name><USR>s:3PwZ5Tokena<\/USR><Declaration>public typealias Token = (tag: Tag, symbol: Symbol)<\/Declaration><CommentParts><Abstract><Para>Tokens are pairs consisting of a tag (identifying the type of the token) and a symbol (identify the token’s text).<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 17,
        "key.doc.name" : "Token",
        "key.doc.type" : "Other",
        "key.doclength" : 123,
        "key.docoffset" : 341,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Token<\/decl.name> = <tuple>(<tuple.element><tuple.element.argument_label>tag<\/tuple.element.argument_label>: <tuple.element.type><ref.typealias usr=\"s:3PwZ3Taga\">Tag<\/ref.typealias><\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.argument_label>symbol<\/tuple.element.argument_label>: <tuple.element.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/tuple.element.type><\/tuple.element>)<\/tuple><\/decl.typealias>",
        "key.kind" : "source.lang.swift.decl.typealias",
        "key.length" : 44,
        "key.name" : "Token",
        "key.namelength" : 5,
        "key.nameoffset" : 481,
        "key.offset" : 471,
        "key.parsed_declaration" : "public typealias Token = (tag: Tag, symbol: Symbol)",
        "key.parsed_scope.end" : 17,
        "key.parsed_scope.start" : 17,
        "key.typename" : "(tag: Int, symbol: String).Type",
        "key.typeusr" : "$sSi3tag_SS6symboltmD",
        "key.usr" : "s:3PwZ5Tokena"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public class Expression : <Type usr=\"s:SQ\">Equatable<\/Type>, <Type usr=\"s:s23CustomStringConvertibleP\">CustomStringConvertible<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 781
          }
        ],
        "key.bodylength" : 1394,
        "key.bodyoffset" : 842,
        "key.doc.column" : 14,
        "key.doc.comment" : "Expressions form trees in a grammar. We use a class instead of a struct to\npreserve reference semantics because grammars may have duplicate references to\nthe same expression multiple times.",
        "key.doc.declaration" : "public class Expression : Equatable, CustomStringConvertible",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"30\" column=\"14\"><Name>Expression<\/Name><USR>s:3PwZ10ExpressionC<\/USR><Declaration>public class Expression : Equatable, CustomStringConvertible<\/Declaration><CommentParts><Abstract><Para>Expressions form trees in a grammar. We use a class instead of a struct to preserve reference semantics because grammars may have duplicate references to the same expression multiple times.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 30,
        "key.doc.name" : "Expression",
        "key.doc.type" : "Class",
        "key.doclength" : 200,
        "key.docoffset" : 580,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 806
          },
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 23,
            "key.offset" : 817
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>Expression<\/decl.name> : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol>, <ref.protocol usr=\"s:s23CustomStringConvertibleP\">CustomStringConvertible<\/ref.protocol><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Equatable"
          },
          {
            "key.name" : "CustomStringConvertible"
          }
        ],
        "key.kind" : "source.lang.swift.decl.class",
        "key.length" : 1449,
        "key.name" : "Expression",
        "key.namelength" : 10,
        "key.nameoffset" : 794,
        "key.offset" : 788,
        "key.parsed_declaration" : "public class Expression: Equatable, CustomStringConvertible",
        "key.parsed_scope.end" : 65,
        "key.parsed_scope.start" : 30,
        "key.runtime_name" : "_TtC4main10Expression",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "Memoization records are pushed into expressions for efficiency.",
            "key.doc.declaration" : "var memoizationRecord: MemoizationRecord",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"32\" column=\"9\"><Name>memoizationRecord<\/Name><USR>s:3PwZ10ExpressionC17memoizationRecordAA011MemoizationD0Cvp<\/USR><Declaration>var memoizationRecord: MemoizationRecord<\/Declaration><CommentParts><Abstract><Para>Memoization records are pushed into expressions for efficiency.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 32,
            "key.doc.name" : "memoizationRecord",
            "key.doc.type" : "Other",
            "key.doclength" : 68,
            "key.docoffset" : 847,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>memoizationRecord<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 40,
            "key.name" : "memoizationRecord",
            "key.namelength" : 17,
            "key.nameoffset" : 923,
            "key.offset" : 919,
            "key.parsed_declaration" : "var memoizationRecord: MemoizationRecord",
            "key.parsed_scope.end" : 32,
            "key.parsed_scope.start" : 32,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "MemoizationRecord",
            "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
            "key.usr" : "s:3PwZ10ExpressionC17memoizationRecordAA011MemoizationD0Cvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var expressionCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type> { get set }<\/Declaration>",
            "key.bodylength" : 156,
            "key.bodyoffset" : 1080,
            "key.doc.column" : 9,
            "key.doc.comment" : "The specific case of expression being represented in this `Expression`.",
            "key.doc.declaration" : "var expressionCase: ExpressionCase { get set }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"34\" column=\"9\"><Name>expressionCase<\/Name><USR>s:3PwZ10ExpressionC14expressionCaseAA0bD0Ovp<\/USR><Declaration>var expressionCase: ExpressionCase { get set }<\/Declaration><CommentParts><Abstract><Para>The specific case of expression being represented in this <codeVoice>Expression<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 34,
            "key.doc.name" : "expressionCase",
            "key.doc.type" : "Other",
            "key.doclength" : 76,
            "key.docoffset" : 964,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>expressionCase<\/decl.name>: <decl.var.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> <syntaxtype.keyword>set<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 193,
            "key.name" : "expressionCase",
            "key.namelength" : 14,
            "key.nameoffset" : 1048,
            "key.offset" : 1044,
            "key.parsed_declaration" : "var expressionCase: ExpressionCase",
            "key.parsed_scope.end" : 38,
            "key.parsed_scope.start" : 34,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "ExpressionCase",
            "key.typeusr" : "$s3PwZ14ExpressionCaseOD",
            "key.usr" : "s:3PwZ10ExpressionC14expressionCaseAA0bD0Ovp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(memoizationRecord memRec: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>, expressionCase expCase: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1348
              }
            ],
            "key.bodylength" : 83,
            "key.bodyoffset" : 1455,
            "key.doc.column" : 12,
            "key.doc.comment" : "Initializes a new `Expression` from a `MemoizationRecord` and internal\n`ExpressionCase`.",
            "key.doc.declaration" : "public init(memoizationRecord memRec: MemoizationRecord, expressionCase expCase: ExpressionCase)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"42\" column=\"12\"><Name>init(memoizationRecord:expressionCase:)<\/Name><USR>s:3PwZ10ExpressionC17memoizationRecord14expressionCaseAcA011MemoizationD0C_AA0bF0Otcfc<\/USR><Declaration>public init(memoizationRecord memRec: MemoizationRecord, expressionCase expCase: ExpressionCase)<\/Declaration><CommentParts><Abstract><Para>Initializes a new <codeVoice>Expression<\/codeVoice> from a <codeVoice>MemoizationRecord<\/codeVoice> and internal <codeVoice>ExpressionCase<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 42,
            "key.doc.name" : "init(memoizationRecord:expressionCase:)",
            "key.doc.type" : "Function",
            "key.doclength" : 101,
            "key.docoffset" : 1243,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>memoizationRecord<\/decl.var.parameter.argument_label> <decl.var.parameter.name>memRec<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>expressionCase<\/decl.var.parameter.argument_label> <decl.var.parameter.name>expCase<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 184,
            "key.name" : "init(memoizationRecord:expressionCase:)",
            "key.namelength" : 98,
            "key.nameoffset" : 1355,
            "key.offset" : 1355,
            "key.parsed_declaration" : "public init(memoizationRecord memRec: MemoizationRecord,\n     expressionCase expCase: ExpressionCase)",
            "key.parsed_scope.end" : 46,
            "key.parsed_scope.start" : 42,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"\">init(expressionCase:)<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(Expression.Type) -> (MemoizationRecord, ExpressionCase) -> Expression",
            "key.typeusr" : "$s17memoizationRecord14expressionCase3PwZ10ExpressionCAC011MemoizationB0C_AC0fD0OtcD",
            "key.usr" : "s:3PwZ10ExpressionC17memoizationRecord14expressionCaseAcA011MemoizationD0C_AA0bF0Otcfc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func == (lhs: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>, rhs: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1616
              }
            ],
            "key.bodylength" : 131,
            "key.bodyoffset" : 1682,
            "key.doc.column" : 24,
            "key.doc.comment" : "`Expression`s are trivially `Equatable` from their components.",
            "key.doc.declaration" : "public static func == (lhs: Expression, rhs: Expression) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"49\" column=\"24\"><Name>==(_:_:)<\/Name><USR>s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ<\/USR><Declaration>public static func == (lhs: Expression, rhs: Expression) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para><codeVoice>Expression<\/codeVoice>s are trivially <codeVoice>Equatable<\/codeVoice> from their components.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 49,
            "key.doc.name" : "==(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 67,
            "key.docoffset" : 1545,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>== <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 191,
            "key.name" : "==(_:_:)",
            "key.namelength" : 37,
            "key.nameoffset" : 1635,
            "key.offset" : 1623,
            "key.overrides" : [
              {
                "key.usr" : "s:SQ2eeoiySbx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func == (lhs: Expression, rhs: Expression) -> Bool",
            "key.parsed_scope.end" : 53,
            "key.parsed_scope.start" : 49,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ\">== (_: ReferenceArray&lt;Element&gt;, _: ReferenceArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ\">== (_: ExpressionCase, _: ExpressionCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ\">== (_: ContextCase, _: ContextCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ\">== (_: MemoizationRecord, _: MemoizationRecord) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbypXpSg_ABtF\">== (_: Any.Type?, _: Any.Type?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_xtSYRzSQ8RawValueRpzlF\">== &lt;T&gt;(_: T, _: T) -&gt; Bool where T : RawRepresentable, T.RawValue : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbyt_yttF\">== (_: (), _: ()) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_t_x_q_ttSQRzSQR_r0_lF\">== &lt;A, B&gt;(_: (A, B), _: (A, B)) -&gt; Bool where A : Equatable, B : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_t_x_q_q0_ttSQRzSQR_SQR0_r1_lF\">== &lt;A, B, C&gt;(_: (A, B, C), _: (A, B, C)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_t_x_q_q0_q1_ttSQRzSQR_SQR0_SQR1_r2_lF\">== &lt;A, B, C, D&gt;(_: (A, B, C, D), _: (A, B, C, D)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_t_x_q_q0_q1_q2_ttSQRzSQR_SQR0_SQR1_SQR2_r3_lF\">== &lt;A, B, C, D, E&gt;(_: (A, B, C, D, E), _: (A, B, C, D, E)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_q3_t_x_q_q0_q1_q2_q3_ttSQRzSQR_SQR0_SQR1_SQR2_SQR3_r4_lF\">== &lt;A, B, C, D, E, F&gt;(_: (A, B, C, D, E, F), _: (A, B, C, D, E, F)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SasSQRzlE2eeoiySbSayxG_ABtFZ\">== (_: Array&lt;Element&gt;, _: Array&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10ArraySliceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ArraySlice&lt;Element&gt;, _: ArraySlice&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sb2eeoiyS2b_SbtFZ\">== (_: Bool, _: Bool) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SJ2eeoiySbSJ_SJtFZ\">== (_: Character, _: Character) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17CodingUserInfoKeyV2eeoiySbAB_ABtFZ\">== (_: CodingUserInfoKey, _: CodingUserInfoKey) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15ContiguousArrayVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ContiguousArray&lt;Element&gt;, _: ContiguousArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SNsSxRzSZ6StrideRpzrlE5IndexO2eeoiySbADyx_G_AFtFZ\">== (_: ClosedRange&lt;Bound&gt;.Index, _: ClosedRange&lt;Bound&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SN2eeoiySbSNyxG_ABtFZ\">== (_: ClosedRange&lt;Bound&gt;, _: ClosedRange&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s13OpaquePointerV2eeoiySbAB_ABtFZ\">== (_: OpaquePointer, _: OpaquePointer) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD4KeysV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Keys, _: Dictionary&lt;Key, Value&gt;.Keys) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SDsSQR_rlE2eeoiySbSDyxq_G_ABtFZ\">== (_: [Key : Value], _: [Key : Value]) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD5IndexV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Index, _: Dictionary&lt;Key, Value&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15EmptyCollectionV2eeoiySbAByxG_ADtFZ\">== (_: EmptyCollection&lt;Element&gt;, _: EmptyCollection&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SQ2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15FlattenSequenceVsSlRzSl7ElementRpzrlE5IndexV2eeoiySbAFyx_G_AHtFZ\">== (_: FlattenCollection&lt;Base&gt;.Index, _: FlattenCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17FloatingPointSignO2eeoiySbAB_ABtFZ\">== (_: FloatingPointSign, _: FloatingPointSign) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s27FloatingPointClassificationO2eeoiySbAB_ABtFZ\">== (_: FloatingPointClassification, _: FloatingPointClassification) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s25FloatingPointRoundingRuleO2eeoiySbAB_ABtFZ\">== (_: FloatingPointRoundingRule, _: FloatingPointRoundingRule) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SFsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11AnyHashableV2eeoiySbAB_ABtFZ\">== (_: AnyHashable, _: AnyHashable) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SzsE2eeoiySbx_qd__tSzRd__lFZ\">== &lt;Other&gt;(_: Self, _: Other) -&gt; Bool where Other : BinaryInteger<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V2eeoiySbAB_ABtFZ\">== (_: UInt8, _: UInt8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V2eeoiySbAB_ABtFZ\">== (_: Int8, _: Int8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V2eeoiySbAB_ABtFZ\">== (_: UInt16, _: UInt16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V2eeoiySbAB_ABtFZ\">== (_: Int16, _: Int16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V2eeoiySbAB_ABtFZ\">== (_: UInt32, _: UInt32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V2eeoiySbAB_ABtFZ\">== (_: Int32, _: Int32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V2eeoiySbAB_ABtFZ\">== (_: UInt64, _: UInt64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V2eeoiySbAB_ABtFZ\">== (_: Int64, _: Int64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su2eeoiySbSu_SutFZ\">== (_: UInt, _: UInt) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si2eeoiySbSi_SitFZ\">== (_: Int, _: Int) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10AnyKeyPathC2eeoiySbAB_ABtFZ\">== (_: AnyKeyPath, _: AnyKeyPath) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20ManagedBufferPointerV2eeoiySbAByxq_G_ADtFZ\">== (_: ManagedBufferPointer&lt;Header, Element&gt;, _: ManagedBufferPointer&lt;Header, Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO6ScalarV2eeoiySbAD_ADtFZ\">== (_: Unicode.Scalar, _: Unicode.Scalar) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SO2eeoiySbSO_SOtFZ\">== (_: ObjectIdentifier, _: ObjectIdentifier) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SqsSQRzlE2eeoiySbxSg_ABtFZ\">== (_: Wrapped?, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbxSg_s26_OptionalNilComparisonTypeVtFZ\">== (_: Wrapped?, _: _OptionalNilComparisonType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbs26_OptionalNilComparisonTypeV_xSgtFZ\">== (_: _OptionalNilComparisonType, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8_PointerPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5NeverO2eeoiySbAB_ABtFZ\">== (_: Never, _: Never) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s23LazyPrefixWhileSequenceVsSlRzrlE5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: LazyPrefixWhileCollection&lt;Base&gt;.Index, _: LazyPrefixWhileCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sn2eeoiySbSnyxG_ABtFZ\">== (_: Range&lt;Bound&gt;, _: Range&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6ResultOsSQRzSQR_rlE2eeoiySbAByxq_G_ADtFZ\">== (_: Result&lt;Success, Failure&gt;, _: Result&lt;Success, Failure&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s18ReversedCollectionV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: ReversedCollection&lt;Base&gt;.Index, _: ReversedCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh2eeoiySbShyxG_ABtFZ\">== (_: Set&lt;Element&gt;, _: Set&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh5IndexV2eeoiySbAByx_G_ADtFZ\">== (_: Set&lt;Element&gt;.Index, _: Set&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SxsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SysE2eeoiySbx_qd__tSyRd__lFZ\">== &lt;RHS&gt;(_: Self, _: RHS) -&gt; Bool where RHS : StringProtocol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS2eeoiySbSS_SStFZ\">== (_: String, _: String) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS5IndexV2eeoiySbAB_ABtFZ\">== (_: String.Index, _: String.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11_UIntBufferV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: _UIntBuffer&lt;Element&gt;.Index, _: _UIntBuffer&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO15GeneralCategoryO2eeoiySbAD_ADtFZ\">== (_: Unicode.GeneralCategory, _: Unicode.GeneralCategory) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO23CanonicalCombiningClassV2eeoiySbAD_ADtFZ\">== (_: Unicode.CanonicalCombiningClass, _: Unicode.CanonicalCombiningClass) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO11NumericTypeO2eeoiySbAD_ADtFZ\">== (_: Unicode.NumericType, _: Unicode.NumericType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO5UTF32O2eeoiySbAD_ADtFZ\">== (_: Unicode.UTF32, _: Unicode.UTF32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s21UnicodeDecodingResultO2eeoiySbAB_ABtFZ\">== (_: UnicodeDecodingResult, _: UnicodeDecodingResult) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s16_ValidUTF8BufferV5IndexV2eeoiySbAD_ADtFZ\">== (_: _ValidUTF8Buffer.Index, _: _ValidUTF8Buffer.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Index, _: CollectionDifference&lt;ChangeElement&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV6ChangeOsSQRzlE2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Change, _: CollectionDifference&lt;ChangeElement&gt;.Change) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;, _: CollectionDifference&lt;ChangeElement&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8AnyIndexV2eeoiySbAB_ABtFZ\">== (_: AnyIndex, _: AnyIndex) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6MirrorV12DisplayStyleO2eeoiySbAD_ADtFZ\">== (_: Mirror.DisplayStyle, _: Mirror.DisplayStyle) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4SIMDPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 1639,
                "key.parent_loc" : 1635,
                "key.parsed_declaration" : "public static func == (lhs",
                "key.parsed_scope.end" : 49,
                "key.parsed_scope.start" : 49,
                "key.typename" : "Expression",
                "key.typeusr" : "$s3PwZ10ExpressionCD",
                "key.usr" : "s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ3lhsL_ACvp"
              }
            ],
            "key.typename" : "(Expression.Type) -> (Expression, Expression) -> Bool",
            "key.typeusr" : "$sySb3PwZ10ExpressionC_ACtcD",
            "key.usr" : "s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>private var _description: <Type usr=\"s:SS\">String<\/Type>?<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.private",
                "key.length" : 7,
                "key.offset" : 1889
              }
            ],
            "key.doc.column" : 17,
            "key.doc.comment" : "A private holder of the actual description, for memoization.",
            "key.doc.declaration" : "private var _description: String?",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"56\" column=\"17\"><Name>_description<\/Name><USR>s:3PwZ10ExpressionC12_description33_BA32D2E92CF1A1850DB97EEE0CE6FC61LLSSSgvp<\/USR><Declaration>private var _description: String?<\/Declaration><CommentParts><Abstract><Para>A private holder of the actual description, for memoization.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 56,
            "key.doc.name" : "_description",
            "key.doc.type" : "Other",
            "key.doclength" : 65,
            "key.docoffset" : 1820,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>private<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>_description<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct>?<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 31,
            "key.name" : "_description",
            "key.namelength" : 12,
            "key.nameoffset" : 1901,
            "key.offset" : 1897,
            "key.parsed_declaration" : "private var _description: String? = nil",
            "key.parsed_scope.end" : 56,
            "key.parsed_scope.start" : 56,
            "key.setter_accessibility" : "source.lang.swift.accessibility.private",
            "key.typename" : "String?",
            "key.typeusr" : "$sSSSgD",
            "key.usr" : "s:3PwZ10ExpressionC12_description33_BA32D2E92CF1A1850DB97EEE0CE6FC61LLSSSgvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public var description: <Type usr=\"s:SS\">String<\/Type> { get }<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2073
              }
            ],
            "key.bodylength" : 129,
            "key.bodyoffset" : 2105,
            "key.doc.column" : 16,
            "key.doc.comment" : "A rendering of the `Expression` to a string. This is lazily computed\nfresh when the `Expression.expressionCase` is updated.",
            "key.doc.declaration" : "public var description: String { get }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"59\" column=\"16\"><Name>description<\/Name><USR>s:3PwZ10ExpressionC11descriptionSSvp<\/USR><Declaration>public var description: String { get }<\/Declaration><CommentParts><Abstract><Para>A rendering of the <codeVoice>Expression<\/codeVoice> to a string. This is lazily computed fresh when the <codeVoice>Expression.expressionCase<\/codeVoice> is updated.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 59,
            "key.doc.name" : "description",
            "key.doc.type" : "Other",
            "key.doclength" : 136,
            "key.docoffset" : 1933,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>description<\/decl.name>: <decl.var.type><ref.struct usr=\"s:SS\">String<\/ref.struct><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 155,
            "key.name" : "description",
            "key.namelength" : 11,
            "key.nameoffset" : 2084,
            "key.offset" : 2080,
            "key.overrides" : [
              {
                "key.usr" : "s:s23CustomStringConvertibleP11descriptionSSvp"
              }
            ],
            "key.parsed_declaration" : "public var description: String",
            "key.parsed_scope.end" : 64,
            "key.parsed_scope.start" : 59,
            "key.typename" : "String",
            "key.typeusr" : "$sSSD",
            "key.usr" : "s:3PwZ10ExpressionC11descriptionSSvp"
          }
        ],
        "key.typename" : "Expression.Type",
        "key.typeusr" : "$s3PwZ10ExpressionCmD",
        "key.usr" : "s:3PwZ10ExpressionC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public indirect enum ExpressionCase : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.indirect",
            "key.length" : 8,
            "key.offset" : 2327
          },
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 2320
          }
        ],
        "key.bodylength" : 1038,
        "key.bodyoffset" : 2368,
        "key.doc.column" : 22,
        "key.doc.comment" : "ExpressionCases encode the particular type of `Expression` being dealt with.",
        "key.doc.declaration" : "public indirect enum ExpressionCase : Equatable",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"68\" column=\"22\"><Name>ExpressionCase<\/Name><USR>s:3PwZ14ExpressionCaseO<\/USR><Declaration>public indirect enum ExpressionCase : Equatable<\/Declaration><CommentParts><Abstract><Para>ExpressionCases encode the particular type of <codeVoice>Expression<\/codeVoice> being dealt with.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 68,
        "key.doc.name" : "ExpressionCase",
        "key.doc.type" : "Other",
        "key.doclength" : 81,
        "key.docoffset" : 2239,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 2357
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>indirect<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>ExpressionCase<\/decl.name> : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.enum>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Equatable"
          }
        ],
        "key.kind" : "source.lang.swift.decl.enum",
        "key.length" : 1071,
        "key.name" : "ExpressionCase",
        "key.namelength" : 14,
        "key.nameoffset" : 2341,
        "key.offset" : 2336,
        "key.parsed_declaration" : "public indirect enum ExpressionCase: Equatable",
        "key.parsed_scope.end" : 91,
        "key.parsed_scope.start" : 68,
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 22,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 2415,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Tok(token: <Type usr=\"s:3PwZ5Tokena\">Token<\/Type>)<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Tokens are trivial constructions.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"70\" column=\"10\"><Name>Tok(token:)<\/Name><USR>s:3PwZ14ExpressionCaseO3TokyACSi3tag_SS6symbolt_tcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Tokens are trivial constructions.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 70,
                "key.doc.name" : "Tok(token:)",
                "key.doc.type" : "Other",
                "key.doclength" : 38,
                "key.docoffset" : 2373,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Tok<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>token<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ5Tokena\">Token<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 17,
                "key.name" : "Tok(token:)",
                "key.namelength" : 17,
                "key.nameoffset" : 2420,
                "key.offset" : 2420,
                "key.parsed_declaration" : "case Tok(token: Token)",
                "key.parsed_scope.end" : 70,
                "key.parsed_scope.start" : 70,
                "key.typename" : "(ExpressionCase.Type) -> ((tag: Int, symbol: String)) -> ExpressionCase",
                "key.typeusr" : "$sy3PwZ14ExpressionCaseOSi3tag_SS6symbolt_tcACmcD",
                "key.usr" : "s:3PwZ14ExpressionCaseO3TokyACSi3tag_SS6symbolt_tcACmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 51,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 2575,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Seq(symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>, expressions: [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>])<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Sequences consist of a `Symbol` (naming the production represented by\nthe sequence) and a sequence of `Expression`s.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"73\" column=\"10\"><Name>Seq(symbol:expressions:)<\/Name><USR>s:3PwZ14ExpressionCaseO3SeqyACSS_SayAA0B0CGtcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Sequences consist of a <codeVoice>Symbol<\/codeVoice> (naming the production represented by the sequence) and a sequence of <codeVoice>Expression<\/codeVoice>s.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 73,
                "key.doc.name" : "Seq(symbol:expressions:)",
                "key.doc.type" : "Other",
                "key.doclength" : 129,
                "key.docoffset" : 2442,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Seq<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>symbol<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>expressions<\/decl.var.parameter.argument_label>: <decl.var.parameter.type>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 46,
                "key.name" : "Seq(symbol:expressions:)",
                "key.namelength" : 46,
                "key.nameoffset" : 2580,
                "key.offset" : 2580,
                "key.parsed_declaration" : "case Seq(symbol: Symbol, expressions: [Expression])",
                "key.parsed_scope.end" : 73,
                "key.parsed_scope.start" : 73,
                "key.typename" : "(ExpressionCase.Type) -> (String, [Expression]) -> ExpressionCase",
                "key.typeusr" : "$sy3PwZ14ExpressionCaseOSS_SayAA0B0CGtcACmcD",
                "key.usr" : "s:3PwZ14ExpressionCaseO3SeqyACSS_SayAA0B0CGtcACmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 49,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 2884,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case Alt(expressions: <Type usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/Type>&lt;<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>&gt;)<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Alternates are not named. They contain a collection of child `Expression`s.\n\nNOTE: The parsing implementation requires that this array can be updated\n      in-place, so we use a `ReferenceArray` instead of a simple array.",
                "key.doc.declaration" : "",
                "key.doc.discussion" : [
                  {
                    "Para" : "NOTE: The parsing implementation requires that this array can be updated in-place, so we use a `ReferenceArray` instead of a simple array."
                  }
                ],
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"80\" column=\"10\"><Name>Alt(expressions:)<\/Name><USR>s:3PwZ14ExpressionCaseO3AltyAcA14ReferenceArrayCyAA0B0CG_tcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Alternates are not named. They contain a collection of child <codeVoice>Expression<\/codeVoice>s.<\/Para><\/Abstract><Discussion><Para>NOTE: The parsing implementation requires that this array can be updated in-place, so we use a <codeVoice>ReferenceArray<\/codeVoice> instead of a simple array.<\/Para><\/Discussion><\/CommentParts><\/Other>",
                "key.doc.line" : 80,
                "key.doc.name" : "Alt(expressions:)",
                "key.doc.type" : "Other",
                "key.doclength" : 248,
                "key.docoffset" : 2631,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>Alt<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>expressions<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ14ReferenceArrayC\">ReferenceArray<\/ref.class>&lt;<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>&gt;<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 44,
                "key.name" : "Alt(expressions:)",
                "key.namelength" : 44,
                "key.nameoffset" : 2889,
                "key.offset" : 2889,
                "key.parsed_declaration" : "case Alt(expressions: ReferenceArray<Expression>)",
                "key.parsed_scope.end" : 80,
                "key.parsed_scope.start" : 80,
                "key.typename" : "(ExpressionCase.Type) -> (ReferenceArray<Expression>) -> ExpressionCase",
                "key.typeusr" : "$sy3PwZ14ExpressionCaseOAA14ReferenceArrayCyAA0B0CG_tcACmcD",
                "key.usr" : "s:3PwZ14ExpressionCaseO3AltyAcA14ReferenceArrayCyAA0B0CG_tcACmF"
              }
            ]
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func == (lhs: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>, rhs: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 3014
              }
            ],
            "key.bodylength" : 316,
            "key.bodyoffset" : 3088,
            "key.doc.column" : 24,
            "key.doc.comment" : "`ExpressionCase`s are trivially `Equatable` from their components.",
            "key.doc.declaration" : "public static func == (lhs: ExpressionCase, rhs: ExpressionCase) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"83\" column=\"24\"><Name>==(_:_:)<\/Name><USR>s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ<\/USR><Declaration>public static func == (lhs: ExpressionCase, rhs: ExpressionCase) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para><codeVoice>ExpressionCase<\/codeVoice>s are trivially <codeVoice>Equatable<\/codeVoice> from their components.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 83,
            "key.doc.name" : "==(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 71,
            "key.docoffset" : 2939,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>== <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 384,
            "key.name" : "==(_:_:)",
            "key.namelength" : 45,
            "key.nameoffset" : 3033,
            "key.offset" : 3021,
            "key.overrides" : [
              {
                "key.usr" : "s:SQ2eeoiySbx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func == (lhs: ExpressionCase, rhs: ExpressionCase) -> Bool",
            "key.parsed_scope.end" : 90,
            "key.parsed_scope.start" : 83,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ\">== (_: ReferenceArray&lt;Element&gt;, _: ReferenceArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ\">== (_: Expression, _: Expression) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ\">== (_: ContextCase, _: ContextCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ\">== (_: MemoizationRecord, _: MemoizationRecord) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbypXpSg_ABtF\">== (_: Any.Type?, _: Any.Type?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_xtSYRzSQ8RawValueRpzlF\">== &lt;T&gt;(_: T, _: T) -&gt; Bool where T : RawRepresentable, T.RawValue : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbyt_yttF\">== (_: (), _: ()) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_t_x_q_ttSQRzSQR_r0_lF\">== &lt;A, B&gt;(_: (A, B), _: (A, B)) -&gt; Bool where A : Equatable, B : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_t_x_q_q0_ttSQRzSQR_SQR0_r1_lF\">== &lt;A, B, C&gt;(_: (A, B, C), _: (A, B, C)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_t_x_q_q0_q1_ttSQRzSQR_SQR0_SQR1_r2_lF\">== &lt;A, B, C, D&gt;(_: (A, B, C, D), _: (A, B, C, D)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_t_x_q_q0_q1_q2_ttSQRzSQR_SQR0_SQR1_SQR2_r3_lF\">== &lt;A, B, C, D, E&gt;(_: (A, B, C, D, E), _: (A, B, C, D, E)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_q3_t_x_q_q0_q1_q2_q3_ttSQRzSQR_SQR0_SQR1_SQR2_SQR3_r4_lF\">== &lt;A, B, C, D, E, F&gt;(_: (A, B, C, D, E, F), _: (A, B, C, D, E, F)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SasSQRzlE2eeoiySbSayxG_ABtFZ\">== (_: Array&lt;Element&gt;, _: Array&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10ArraySliceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ArraySlice&lt;Element&gt;, _: ArraySlice&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sb2eeoiyS2b_SbtFZ\">== (_: Bool, _: Bool) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SJ2eeoiySbSJ_SJtFZ\">== (_: Character, _: Character) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17CodingUserInfoKeyV2eeoiySbAB_ABtFZ\">== (_: CodingUserInfoKey, _: CodingUserInfoKey) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15ContiguousArrayVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ContiguousArray&lt;Element&gt;, _: ContiguousArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SNsSxRzSZ6StrideRpzrlE5IndexO2eeoiySbADyx_G_AFtFZ\">== (_: ClosedRange&lt;Bound&gt;.Index, _: ClosedRange&lt;Bound&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SN2eeoiySbSNyxG_ABtFZ\">== (_: ClosedRange&lt;Bound&gt;, _: ClosedRange&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s13OpaquePointerV2eeoiySbAB_ABtFZ\">== (_: OpaquePointer, _: OpaquePointer) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD4KeysV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Keys, _: Dictionary&lt;Key, Value&gt;.Keys) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SDsSQR_rlE2eeoiySbSDyxq_G_ABtFZ\">== (_: [Key : Value], _: [Key : Value]) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD5IndexV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Index, _: Dictionary&lt;Key, Value&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15EmptyCollectionV2eeoiySbAByxG_ADtFZ\">== (_: EmptyCollection&lt;Element&gt;, _: EmptyCollection&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SQ2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15FlattenSequenceVsSlRzSl7ElementRpzrlE5IndexV2eeoiySbAFyx_G_AHtFZ\">== (_: FlattenCollection&lt;Base&gt;.Index, _: FlattenCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17FloatingPointSignO2eeoiySbAB_ABtFZ\">== (_: FloatingPointSign, _: FloatingPointSign) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s27FloatingPointClassificationO2eeoiySbAB_ABtFZ\">== (_: FloatingPointClassification, _: FloatingPointClassification) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s25FloatingPointRoundingRuleO2eeoiySbAB_ABtFZ\">== (_: FloatingPointRoundingRule, _: FloatingPointRoundingRule) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SFsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11AnyHashableV2eeoiySbAB_ABtFZ\">== (_: AnyHashable, _: AnyHashable) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SzsE2eeoiySbx_qd__tSzRd__lFZ\">== &lt;Other&gt;(_: Self, _: Other) -&gt; Bool where Other : BinaryInteger<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V2eeoiySbAB_ABtFZ\">== (_: UInt8, _: UInt8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V2eeoiySbAB_ABtFZ\">== (_: Int8, _: Int8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V2eeoiySbAB_ABtFZ\">== (_: UInt16, _: UInt16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V2eeoiySbAB_ABtFZ\">== (_: Int16, _: Int16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V2eeoiySbAB_ABtFZ\">== (_: UInt32, _: UInt32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V2eeoiySbAB_ABtFZ\">== (_: Int32, _: Int32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V2eeoiySbAB_ABtFZ\">== (_: UInt64, _: UInt64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V2eeoiySbAB_ABtFZ\">== (_: Int64, _: Int64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su2eeoiySbSu_SutFZ\">== (_: UInt, _: UInt) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si2eeoiySbSi_SitFZ\">== (_: Int, _: Int) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10AnyKeyPathC2eeoiySbAB_ABtFZ\">== (_: AnyKeyPath, _: AnyKeyPath) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20ManagedBufferPointerV2eeoiySbAByxq_G_ADtFZ\">== (_: ManagedBufferPointer&lt;Header, Element&gt;, _: ManagedBufferPointer&lt;Header, Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO6ScalarV2eeoiySbAD_ADtFZ\">== (_: Unicode.Scalar, _: Unicode.Scalar) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SO2eeoiySbSO_SOtFZ\">== (_: ObjectIdentifier, _: ObjectIdentifier) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SqsSQRzlE2eeoiySbxSg_ABtFZ\">== (_: Wrapped?, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbxSg_s26_OptionalNilComparisonTypeVtFZ\">== (_: Wrapped?, _: _OptionalNilComparisonType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbs26_OptionalNilComparisonTypeV_xSgtFZ\">== (_: _OptionalNilComparisonType, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8_PointerPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5NeverO2eeoiySbAB_ABtFZ\">== (_: Never, _: Never) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s23LazyPrefixWhileSequenceVsSlRzrlE5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: LazyPrefixWhileCollection&lt;Base&gt;.Index, _: LazyPrefixWhileCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sn2eeoiySbSnyxG_ABtFZ\">== (_: Range&lt;Bound&gt;, _: Range&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6ResultOsSQRzSQR_rlE2eeoiySbAByxq_G_ADtFZ\">== (_: Result&lt;Success, Failure&gt;, _: Result&lt;Success, Failure&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s18ReversedCollectionV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: ReversedCollection&lt;Base&gt;.Index, _: ReversedCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh2eeoiySbShyxG_ABtFZ\">== (_: Set&lt;Element&gt;, _: Set&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh5IndexV2eeoiySbAByx_G_ADtFZ\">== (_: Set&lt;Element&gt;.Index, _: Set&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SxsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SysE2eeoiySbx_qd__tSyRd__lFZ\">== &lt;RHS&gt;(_: Self, _: RHS) -&gt; Bool where RHS : StringProtocol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS2eeoiySbSS_SStFZ\">== (_: String, _: String) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS5IndexV2eeoiySbAB_ABtFZ\">== (_: String.Index, _: String.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11_UIntBufferV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: _UIntBuffer&lt;Element&gt;.Index, _: _UIntBuffer&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO15GeneralCategoryO2eeoiySbAD_ADtFZ\">== (_: Unicode.GeneralCategory, _: Unicode.GeneralCategory) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO23CanonicalCombiningClassV2eeoiySbAD_ADtFZ\">== (_: Unicode.CanonicalCombiningClass, _: Unicode.CanonicalCombiningClass) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO11NumericTypeO2eeoiySbAD_ADtFZ\">== (_: Unicode.NumericType, _: Unicode.NumericType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO5UTF32O2eeoiySbAD_ADtFZ\">== (_: Unicode.UTF32, _: Unicode.UTF32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s21UnicodeDecodingResultO2eeoiySbAB_ABtFZ\">== (_: UnicodeDecodingResult, _: UnicodeDecodingResult) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s16_ValidUTF8BufferV5IndexV2eeoiySbAD_ADtFZ\">== (_: _ValidUTF8Buffer.Index, _: _ValidUTF8Buffer.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Index, _: CollectionDifference&lt;ChangeElement&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV6ChangeOsSQRzlE2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Change, _: CollectionDifference&lt;ChangeElement&gt;.Change) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;, _: CollectionDifference&lt;ChangeElement&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8AnyIndexV2eeoiySbAB_ABtFZ\">== (_: AnyIndex, _: AnyIndex) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6MirrorV12DisplayStyleO2eeoiySbAD_ADtFZ\">== (_: Mirror.DisplayStyle, _: Mirror.DisplayStyle) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4SIMDPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 3037,
                "key.parent_loc" : 3033,
                "key.parsed_declaration" : "public static func == (lhs",
                "key.parsed_scope.end" : 83,
                "key.parsed_scope.start" : 83,
                "key.typename" : "ExpressionCase",
                "key.typeusr" : "$s3PwZ14ExpressionCaseOD",
                "key.usr" : "s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ3lhsL_ACvp"
              }
            ],
            "key.typename" : "(ExpressionCase.Type) -> (ExpressionCase, ExpressionCase) -> Bool",
            "key.typeusr" : "$sySb3PwZ14ExpressionCaseO_ACtcD",
            "key.usr" : "s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ"
          }
        ],
        "key.typename" : "ExpressionCase.Type",
        "key.typeusr" : "$s3PwZ14ExpressionCaseOmD",
        "key.usr" : "s:3PwZ14ExpressionCaseO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public indirect enum ContextCase : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.indirect",
            "key.length" : 8,
            "key.offset" : 3492
          },
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 3485
          }
        ],
        "key.bodylength" : 1192,
        "key.bodyoffset" : 3530,
        "key.doc.column" : 22,
        "key.doc.comment" : "ContextCases represent the context of a zipper's focused-on expression.",
        "key.doc.declaration" : "public indirect enum ContextCase : Equatable",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"94\" column=\"22\"><Name>ContextCase<\/Name><USR>s:3PwZ11ContextCaseO<\/USR><Declaration>public indirect enum ContextCase : Equatable<\/Declaration><CommentParts><Abstract><Para>ContextCases represent the context of a zipper’s focused-on expression.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 94,
        "key.doc.name" : "ContextCase",
        "key.doc.type" : "Other",
        "key.doclength" : 76,
        "key.docoffset" : 3409,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 3519
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.enum><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>indirect<\/syntaxtype.keyword> <syntaxtype.keyword>enum<\/syntaxtype.keyword> <decl.name>ContextCase<\/decl.name> : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.enum>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Equatable"
          }
        ],
        "key.kind" : "source.lang.swift.decl.enum",
        "key.length" : 1222,
        "key.name" : "ContextCase",
        "key.namelength" : 11,
        "key.nameoffset" : 3506,
        "key.offset" : 3501,
        "key.parsed_declaration" : "public indirect enum ContextCase: Equatable",
        "key.parsed_scope.end" : 118,
        "key.parsed_scope.start" : 94,
        "key.substructure" : [
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 9,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 3589,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case TopC<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "The special case for the root of the grammar.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"96\" column=\"10\"><Name>TopC<\/Name><USR>s:3PwZ11ContextCaseO4TopCyA2CmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>The special case for the root of the grammar.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 96,
                "key.doc.name" : "TopC",
                "key.doc.type" : "Other",
                "key.doclength" : 50,
                "key.docoffset" : 3535,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>TopC<\/decl.name><\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 4,
                "key.name" : "TopC",
                "key.namelength" : 4,
                "key.nameoffset" : 3594,
                "key.offset" : 3594,
                "key.parsed_declaration" : "case TopC",
                "key.parsed_scope.end" : 96,
                "key.parsed_scope.start" : 96,
                "key.typename" : "(ContextCase.Type) -> ContextCase",
                "key.typeusr" : "$sy3PwZ11ContextCaseOACmcD",
                "key.usr" : "s:3PwZ11ContextCaseO4TopCyA2CmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 168,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 3847,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case SeqC(memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>, symbol: <Type usr=\"s:3PwZ6Symbola\">Symbol<\/Type>, leftExpressions: [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>], rightExpressions: [<Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>])<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Contexts for `Seq`, consisting of a `MemoizationRecord`, the sequence's\nproduction name, and two lists of `Expression`s representing the left and\nright siblings of the current focused-on expression in the zipper.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"102\" column=\"10\"><Name>SeqC(memoizationRecord:symbol:leftExpressions:rightExpressions:)<\/Name><USR>s:3PwZ11ContextCaseO4SeqCyAcA17MemoizationRecordC_SSSayAA10ExpressionCGAItcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Contexts for <codeVoice>Seq<\/codeVoice>, consisting of a <codeVoice>MemoizationRecord<\/codeVoice>, the sequence’s production name, and two lists of <codeVoice>Expression<\/codeVoice>s representing the left and right siblings of the current focused-on expression in the zipper.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 102,
                "key.doc.name" : "SeqC(memoizationRecord:symbol:leftExpressions:rightExpressions:)",
                "key.doc.type" : "Other",
                "key.doclength" : 239,
                "key.docoffset" : 3603,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>SeqC<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>memoizationRecord<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>symbol<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ6Symbola\">Symbol<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>leftExpressions<\/decl.var.parameter.argument_label>: <decl.var.parameter.type>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>rightExpressions<\/decl.var.parameter.argument_label>: <decl.var.parameter.type>[<ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>]<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 163,
                "key.name" : "SeqC(memoizationRecord:symbol:leftExpressions:rightExpressions:)",
                "key.namelength" : 163,
                "key.nameoffset" : 3852,
                "key.offset" : 3852,
                "key.parsed_declaration" : "case SeqC(memoizationRecord: MemoizationRecord,\n          symbol: Symbol,\n          leftExpressions: [Expression],\n          rightExpressions: [Expression])",
                "key.parsed_scope.end" : 102,
                "key.parsed_scope.start" : 102,
                "key.typename" : "(ContextCase.Type) -> (MemoizationRecord, String, [Expression], [Expression]) -> ContextCase",
                "key.typeusr" : "$sy3PwZ11ContextCaseOAA17MemoizationRecordC_SSSayAA10ExpressionCGAHtcACmcD",
                "key.usr" : "s:3PwZ11ContextCaseO4SeqCyAcA17MemoizationRecordC_SSSayAA10ExpressionCGAItcACmF"
              }
            ]
          },
          {
            "key.kind" : "source.lang.swift.decl.enumcase",
            "key.length" : 47,
            "key.namelength" : 0,
            "key.nameoffset" : 0,
            "key.offset" : 4091,
            "key.substructure" : [
              {
                "key.accessibility" : "source.lang.swift.accessibility.public",
                "key.annotated_decl" : "<Declaration>case AltC(memoizationRecord: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>)<\/Declaration>",
                "key.doc.column" : 10,
                "key.doc.comment" : "Contexts for `Alt`, which contains only a `MemoizationRecord`.",
                "key.doc.declaration" : "",
                "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"107\" column=\"10\"><Name>AltC(memoizationRecord:)<\/Name><USR>s:3PwZ11ContextCaseO4AltCyAcA17MemoizationRecordC_tcACmF<\/USR><Declaration><\/Declaration><CommentParts><Abstract><Para>Contexts for <codeVoice>Alt<\/codeVoice>, which contains only a <codeVoice>MemoizationRecord<\/codeVoice>.<\/Para><\/Abstract><\/CommentParts><\/Other>",
                "key.doc.line" : 107,
                "key.doc.name" : "AltC(memoizationRecord:)",
                "key.doc.type" : "Other",
                "key.doclength" : 67,
                "key.docoffset" : 4020,
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.enumelement><syntaxtype.keyword>case<\/syntaxtype.keyword> <decl.name>AltC<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>memoizationRecord<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.enumelement>",
                "key.kind" : "source.lang.swift.decl.enumelement",
                "key.length" : 42,
                "key.name" : "AltC(memoizationRecord:)",
                "key.namelength" : 42,
                "key.nameoffset" : 4096,
                "key.offset" : 4096,
                "key.parsed_declaration" : "case AltC(memoizationRecord: MemoizationRecord)",
                "key.parsed_scope.end" : 107,
                "key.parsed_scope.start" : 107,
                "key.typename" : "(ContextCase.Type) -> (MemoizationRecord) -> ContextCase",
                "key.typeusr" : "$sy3PwZ11ContextCaseOAA17MemoizationRecordC_tcACmcD",
                "key.usr" : "s:3PwZ11ContextCaseO4AltCyAcA17MemoizationRecordC_tcACmF"
              }
            ]
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func == (lhs: <Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>, rhs: <Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 4216
              }
            ],
            "key.bodylength" : 436,
            "key.bodyoffset" : 4284,
            "key.doc.column" : 24,
            "key.doc.comment" : "`ContextCase`s are trivially `Equatable` from their components.",
            "key.doc.declaration" : "public static func == (lhs: ContextCase, rhs: ContextCase) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"110\" column=\"24\"><Name>==(_:_:)<\/Name><USR>s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ<\/USR><Declaration>public static func == (lhs: ContextCase, rhs: ContextCase) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para><codeVoice>ContextCase<\/codeVoice>s are trivially <codeVoice>Equatable<\/codeVoice> from their components.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 110,
            "key.doc.name" : "==(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 68,
            "key.docoffset" : 4144,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>== <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 498,
            "key.name" : "==(_:_:)",
            "key.namelength" : 39,
            "key.nameoffset" : 4235,
            "key.offset" : 4223,
            "key.overrides" : [
              {
                "key.usr" : "s:SQ2eeoiySbx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func == (lhs: ContextCase, rhs: ContextCase) -> Bool",
            "key.parsed_scope.end" : 117,
            "key.parsed_scope.start" : 110,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ\">== (_: ReferenceArray&lt;Element&gt;, _: ReferenceArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ\">== (_: Expression, _: Expression) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ\">== (_: ExpressionCase, _: ExpressionCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ\">== (_: MemoizationRecord, _: MemoizationRecord) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbypXpSg_ABtF\">== (_: Any.Type?, _: Any.Type?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_xtSYRzSQ8RawValueRpzlF\">== &lt;T&gt;(_: T, _: T) -&gt; Bool where T : RawRepresentable, T.RawValue : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbyt_yttF\">== (_: (), _: ()) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_t_x_q_ttSQRzSQR_r0_lF\">== &lt;A, B&gt;(_: (A, B), _: (A, B)) -&gt; Bool where A : Equatable, B : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_t_x_q_q0_ttSQRzSQR_SQR0_r1_lF\">== &lt;A, B, C&gt;(_: (A, B, C), _: (A, B, C)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_t_x_q_q0_q1_ttSQRzSQR_SQR0_SQR1_r2_lF\">== &lt;A, B, C, D&gt;(_: (A, B, C, D), _: (A, B, C, D)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_t_x_q_q0_q1_q2_ttSQRzSQR_SQR0_SQR1_SQR2_r3_lF\">== &lt;A, B, C, D, E&gt;(_: (A, B, C, D, E), _: (A, B, C, D, E)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_q3_t_x_q_q0_q1_q2_q3_ttSQRzSQR_SQR0_SQR1_SQR2_SQR3_r4_lF\">== &lt;A, B, C, D, E, F&gt;(_: (A, B, C, D, E, F), _: (A, B, C, D, E, F)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SasSQRzlE2eeoiySbSayxG_ABtFZ\">== (_: Array&lt;Element&gt;, _: Array&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10ArraySliceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ArraySlice&lt;Element&gt;, _: ArraySlice&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sb2eeoiyS2b_SbtFZ\">== (_: Bool, _: Bool) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SJ2eeoiySbSJ_SJtFZ\">== (_: Character, _: Character) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17CodingUserInfoKeyV2eeoiySbAB_ABtFZ\">== (_: CodingUserInfoKey, _: CodingUserInfoKey) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15ContiguousArrayVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ContiguousArray&lt;Element&gt;, _: ContiguousArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SNsSxRzSZ6StrideRpzrlE5IndexO2eeoiySbADyx_G_AFtFZ\">== (_: ClosedRange&lt;Bound&gt;.Index, _: ClosedRange&lt;Bound&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SN2eeoiySbSNyxG_ABtFZ\">== (_: ClosedRange&lt;Bound&gt;, _: ClosedRange&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s13OpaquePointerV2eeoiySbAB_ABtFZ\">== (_: OpaquePointer, _: OpaquePointer) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD4KeysV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Keys, _: Dictionary&lt;Key, Value&gt;.Keys) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SDsSQR_rlE2eeoiySbSDyxq_G_ABtFZ\">== (_: [Key : Value], _: [Key : Value]) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD5IndexV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Index, _: Dictionary&lt;Key, Value&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15EmptyCollectionV2eeoiySbAByxG_ADtFZ\">== (_: EmptyCollection&lt;Element&gt;, _: EmptyCollection&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SQ2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15FlattenSequenceVsSlRzSl7ElementRpzrlE5IndexV2eeoiySbAFyx_G_AHtFZ\">== (_: FlattenCollection&lt;Base&gt;.Index, _: FlattenCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17FloatingPointSignO2eeoiySbAB_ABtFZ\">== (_: FloatingPointSign, _: FloatingPointSign) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s27FloatingPointClassificationO2eeoiySbAB_ABtFZ\">== (_: FloatingPointClassification, _: FloatingPointClassification) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s25FloatingPointRoundingRuleO2eeoiySbAB_ABtFZ\">== (_: FloatingPointRoundingRule, _: FloatingPointRoundingRule) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SFsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11AnyHashableV2eeoiySbAB_ABtFZ\">== (_: AnyHashable, _: AnyHashable) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SzsE2eeoiySbx_qd__tSzRd__lFZ\">== &lt;Other&gt;(_: Self, _: Other) -&gt; Bool where Other : BinaryInteger<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V2eeoiySbAB_ABtFZ\">== (_: UInt8, _: UInt8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V2eeoiySbAB_ABtFZ\">== (_: Int8, _: Int8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V2eeoiySbAB_ABtFZ\">== (_: UInt16, _: UInt16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V2eeoiySbAB_ABtFZ\">== (_: Int16, _: Int16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V2eeoiySbAB_ABtFZ\">== (_: UInt32, _: UInt32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V2eeoiySbAB_ABtFZ\">== (_: Int32, _: Int32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V2eeoiySbAB_ABtFZ\">== (_: UInt64, _: UInt64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V2eeoiySbAB_ABtFZ\">== (_: Int64, _: Int64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su2eeoiySbSu_SutFZ\">== (_: UInt, _: UInt) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si2eeoiySbSi_SitFZ\">== (_: Int, _: Int) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10AnyKeyPathC2eeoiySbAB_ABtFZ\">== (_: AnyKeyPath, _: AnyKeyPath) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20ManagedBufferPointerV2eeoiySbAByxq_G_ADtFZ\">== (_: ManagedBufferPointer&lt;Header, Element&gt;, _: ManagedBufferPointer&lt;Header, Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO6ScalarV2eeoiySbAD_ADtFZ\">== (_: Unicode.Scalar, _: Unicode.Scalar) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SO2eeoiySbSO_SOtFZ\">== (_: ObjectIdentifier, _: ObjectIdentifier) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SqsSQRzlE2eeoiySbxSg_ABtFZ\">== (_: Wrapped?, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbxSg_s26_OptionalNilComparisonTypeVtFZ\">== (_: Wrapped?, _: _OptionalNilComparisonType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbs26_OptionalNilComparisonTypeV_xSgtFZ\">== (_: _OptionalNilComparisonType, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8_PointerPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5NeverO2eeoiySbAB_ABtFZ\">== (_: Never, _: Never) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s23LazyPrefixWhileSequenceVsSlRzrlE5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: LazyPrefixWhileCollection&lt;Base&gt;.Index, _: LazyPrefixWhileCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sn2eeoiySbSnyxG_ABtFZ\">== (_: Range&lt;Bound&gt;, _: Range&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6ResultOsSQRzSQR_rlE2eeoiySbAByxq_G_ADtFZ\">== (_: Result&lt;Success, Failure&gt;, _: Result&lt;Success, Failure&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s18ReversedCollectionV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: ReversedCollection&lt;Base&gt;.Index, _: ReversedCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh2eeoiySbShyxG_ABtFZ\">== (_: Set&lt;Element&gt;, _: Set&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh5IndexV2eeoiySbAByx_G_ADtFZ\">== (_: Set&lt;Element&gt;.Index, _: Set&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SxsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SysE2eeoiySbx_qd__tSyRd__lFZ\">== &lt;RHS&gt;(_: Self, _: RHS) -&gt; Bool where RHS : StringProtocol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS2eeoiySbSS_SStFZ\">== (_: String, _: String) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS5IndexV2eeoiySbAB_ABtFZ\">== (_: String.Index, _: String.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11_UIntBufferV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: _UIntBuffer&lt;Element&gt;.Index, _: _UIntBuffer&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO15GeneralCategoryO2eeoiySbAD_ADtFZ\">== (_: Unicode.GeneralCategory, _: Unicode.GeneralCategory) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO23CanonicalCombiningClassV2eeoiySbAD_ADtFZ\">== (_: Unicode.CanonicalCombiningClass, _: Unicode.CanonicalCombiningClass) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO11NumericTypeO2eeoiySbAD_ADtFZ\">== (_: Unicode.NumericType, _: Unicode.NumericType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO5UTF32O2eeoiySbAD_ADtFZ\">== (_: Unicode.UTF32, _: Unicode.UTF32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s21UnicodeDecodingResultO2eeoiySbAB_ABtFZ\">== (_: UnicodeDecodingResult, _: UnicodeDecodingResult) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s16_ValidUTF8BufferV5IndexV2eeoiySbAD_ADtFZ\">== (_: _ValidUTF8Buffer.Index, _: _ValidUTF8Buffer.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Index, _: CollectionDifference&lt;ChangeElement&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV6ChangeOsSQRzlE2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Change, _: CollectionDifference&lt;ChangeElement&gt;.Change) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;, _: CollectionDifference&lt;ChangeElement&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8AnyIndexV2eeoiySbAB_ABtFZ\">== (_: AnyIndex, _: AnyIndex) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6MirrorV12DisplayStyleO2eeoiySbAD_ADtFZ\">== (_: Mirror.DisplayStyle, _: Mirror.DisplayStyle) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4SIMDPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 4239,
                "key.parent_loc" : 4235,
                "key.parsed_declaration" : "public static func == (lhs",
                "key.parsed_scope.end" : 110,
                "key.parsed_scope.start" : 110,
                "key.typename" : "ContextCase",
                "key.typeusr" : "$s3PwZ11ContextCaseOD",
                "key.usr" : "s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ3lhsL_ACvp"
              }
            ],
            "key.typename" : "(ContextCase.Type) -> (ContextCase, ContextCase) -> Bool",
            "key.typeusr" : "$sySb3PwZ11ContextCaseO_ACtcD",
            "key.usr" : "s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ"
          }
        ],
        "key.typename" : "ContextCase.Type",
        "key.typeusr" : "$s3PwZ11ContextCaseOmD",
        "key.usr" : "s:3PwZ11ContextCaseO"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public class MemoizationRecord : <Type usr=\"s:SQ\">Equatable<\/Type><\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 4844
          }
        ],
        "key.bodylength" : 1514,
        "key.bodyoffset" : 4887,
        "key.doc.column" : 14,
        "key.doc.comment" : "Memoization records are used to fix recursion, cycles, and duplication in\ncertain kinds of grammar traversals.",
        "key.doc.declaration" : "public class MemoizationRecord : Equatable",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"122\" column=\"14\"><Name>MemoizationRecord<\/Name><USR>s:3PwZ17MemoizationRecordC<\/USR><Declaration>public class MemoizationRecord : Equatable<\/Declaration><CommentParts><Abstract><Para>Memoization records are used to fix recursion, cycles, and duplication in certain kinds of grammar traversals.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 122,
        "key.doc.name" : "MemoizationRecord",
        "key.doc.type" : "Class",
        "key.doclength" : 119,
        "key.docoffset" : 4725,
        "key.elements" : [
          {
            "key.kind" : "source.lang.swift.structure.elem.typeref",
            "key.length" : 9,
            "key.offset" : 4876
          }
        ],
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <decl.name>MemoizationRecord<\/decl.name> : <ref.protocol usr=\"s:SQ\">Equatable<\/ref.protocol><\/decl.class>",
        "key.inheritedtypes" : [
          {
            "key.name" : "Equatable"
          }
        ],
        "key.kind" : "source.lang.swift.decl.class",
        "key.length" : 1551,
        "key.name" : "MemoizationRecord",
        "key.namelength" : 17,
        "key.nameoffset" : 4857,
        "key.offset" : 4851,
        "key.parsed_declaration" : "public class MemoizationRecord: Equatable",
        "key.parsed_scope.end" : 157,
        "key.parsed_scope.start" : 122,
        "key.runtime_name" : "_TtC4main17MemoizationRecord",
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>let startPosition: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type><\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "The position of the first token in the input to which this memoization\nrecord corresponds.",
            "key.doc.declaration" : "let startPosition: Position",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"125\" column=\"9\"><Name>startPosition<\/Name><USR>s:3PwZ17MemoizationRecordC13startPositionSivp<\/USR><Declaration>let startPosition: Position<\/Declaration><CommentParts><Abstract><Para>The position of the first token in the input to which this memoization record corresponds.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 125,
            "key.doc.name" : "startPosition",
            "key.doc.type" : "Other",
            "key.doclength" : 103,
            "key.docoffset" : 4892,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>startPosition<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 27,
            "key.name" : "startPosition",
            "key.namelength" : 13,
            "key.nameoffset" : 5003,
            "key.offset" : 4999,
            "key.parsed_declaration" : "let startPosition: Position",
            "key.parsed_scope.end" : 125,
            "key.parsed_scope.start" : 125,
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ17MemoizationRecordC13startPositionSivp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var endPosition: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type><\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "The position of the last token in the input to which this memoization\nrecord corresponds.",
            "key.doc.declaration" : "var endPosition: Position",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"128\" column=\"9\"><Name>endPosition<\/Name><USR>s:3PwZ17MemoizationRecordC11endPositionSivp<\/USR><Declaration>var endPosition: Position<\/Declaration><CommentParts><Abstract><Para>The position of the last token in the input to which this memoization record corresponds.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 128,
            "key.doc.name" : "endPosition",
            "key.doc.type" : "Other",
            "key.doclength" : 102,
            "key.docoffset" : 5031,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>endPosition<\/decl.name>: <decl.var.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 25,
            "key.name" : "endPosition",
            "key.namelength" : 11,
            "key.nameoffset" : 5141,
            "key.offset" : 5137,
            "key.parsed_declaration" : "var endPosition: Position",
            "key.parsed_scope.end" : 128,
            "key.parsed_scope.start" : 128,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "Int",
            "key.typeusr" : "$sSiD",
            "key.usr" : "s:3PwZ17MemoizationRecordC11endPositionSivp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var parentContexts: [<Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>]<\/Declaration>",
            "key.doc.column" : 9,
            "key.doc.comment" : "Parent contexts to which this memoization record shall report its\nresult when needed.",
            "key.doc.declaration" : "var parentContexts: [ContextCase]",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"131\" column=\"9\"><Name>parentContexts<\/Name><USR>s:3PwZ17MemoizationRecordC14parentContextsSayAA11ContextCaseOGvp<\/USR><Declaration>var parentContexts: [ContextCase]<\/Declaration><CommentParts><Abstract><Para>Parent contexts to which this memoization record shall report its result when needed.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 131,
            "key.doc.name" : "parentContexts",
            "key.doc.type" : "Other",
            "key.doclength" : 98,
            "key.docoffset" : 5167,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>parentContexts<\/decl.name>: <decl.var.type>[<ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum>]<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 33,
            "key.name" : "parentContexts",
            "key.namelength" : 14,
            "key.nameoffset" : 5273,
            "key.offset" : 5269,
            "key.parsed_declaration" : "var parentContexts: [ContextCase]",
            "key.parsed_scope.end" : 131,
            "key.parsed_scope.start" : 131,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "[ContextCase]",
            "key.typeusr" : "$sSay3PwZ11ContextCaseOGD",
            "key.usr" : "s:3PwZ17MemoizationRecordC14parentContextsSayAA11ContextCaseOGvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.internal",
            "key.annotated_decl" : "<Declaration>var resultExpression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type> { get set }<\/Declaration>",
            "key.bodylength" : 97,
            "key.bodyoffset" : 5416,
            "key.doc.column" : 9,
            "key.doc.comment" : "The expression resulting from the parse over the indicated region.",
            "key.doc.declaration" : "var resultExpression: Expression { get set }",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"133\" column=\"9\"><Name>resultExpression<\/Name><USR>s:3PwZ17MemoizationRecordC16resultExpressionAA0E0Cvp<\/USR><Declaration>var resultExpression: Expression { get set }<\/Declaration><CommentParts><Abstract><Para>The expression resulting from the parse over the indicated region.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 133,
            "key.doc.name" : "resultExpression",
            "key.doc.type" : "Other",
            "key.doclength" : 71,
            "key.docoffset" : 5307,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>resultExpression<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class><\/decl.var.type> { <syntaxtype.keyword>get<\/syntaxtype.keyword> <syntaxtype.keyword>set<\/syntaxtype.keyword> }<\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 132,
            "key.name" : "resultExpression",
            "key.namelength" : 16,
            "key.nameoffset" : 5386,
            "key.offset" : 5382,
            "key.parsed_declaration" : "var resultExpression: Expression",
            "key.parsed_scope.end" : 136,
            "key.parsed_scope.start" : 133,
            "key.setter_accessibility" : "source.lang.swift.accessibility.internal",
            "key.typename" : "Expression",
            "key.typeusr" : "$s3PwZ10ExpressionCD",
            "key.usr" : "s:3PwZ17MemoizationRecordC16resultExpressionAA0E0Cvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.private",
            "key.annotated_decl" : "<Declaration>private var _resultExpression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>?<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.private",
                "key.length" : 7,
                "key.offset" : 5575
              }
            ],
            "key.doc.column" : 17,
            "key.doc.comment" : "The internal representation of the expression.",
            "key.doc.declaration" : "private var _resultExpression: PwZ.Expression?",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"139\" column=\"17\"><Name>_resultExpression<\/Name><USR>s:3PwZ17MemoizationRecordC17_resultExpression33_BA32D2E92CF1A1850DB97EEE0CE6FC61LLAA0E0CSgvp<\/USR><Declaration>private var _resultExpression: PwZ.Expression?<\/Declaration><CommentParts><Abstract><Para>The internal representation of the expression.<\/Para><\/Abstract><\/CommentParts><\/Other>",
            "key.doc.line" : 139,
            "key.doc.name" : "_resultExpression",
            "key.doc.type" : "Other",
            "key.doclength" : 51,
            "key.docoffset" : 5520,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.var.instance><syntaxtype.keyword>private<\/syntaxtype.keyword> <syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>_resultExpression<\/decl.name>: <decl.var.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>?<\/decl.var.type><\/decl.var.instance>",
            "key.kind" : "source.lang.swift.decl.var.instance",
            "key.length" : 34,
            "key.name" : "_resultExpression",
            "key.namelength" : 17,
            "key.nameoffset" : 5587,
            "key.offset" : 5583,
            "key.parsed_declaration" : "private var _resultExpression: Expression?",
            "key.parsed_scope.end" : 139,
            "key.parsed_scope.start" : 139,
            "key.setter_accessibility" : "source.lang.swift.accessibility.private",
            "key.typename" : "Expression?",
            "key.typeusr" : "$s3PwZ10ExpressionCSgD",
            "key.usr" : "s:3PwZ17MemoizationRecordC17_resultExpression33_BA32D2E92CF1A1850DB97EEE0CE6FC61LLAA0E0CSgvp"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public init(startPosition: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type>, endPosition: <Type usr=\"s:3PwZ8Positiona\">Position<\/Type>, parentContexts: [<Type usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/Type>], resultExpression: <Type usr=\"s:3PwZ10ExpressionC\">Expression<\/Type>?)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 5700
              }
            ],
            "key.bodylength" : 182,
            "key.bodyoffset" : 5823,
            "key.doc.column" : 12,
            "key.doc.comment" : "Initializes a new `MemoizationRecord` from the necessary components.",
            "key.doc.declaration" : "public init(startPosition: Position, endPosition: Position, parentContexts: [ContextCase], resultExpression: Expression?)",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"142\" column=\"12\"><Name>init(startPosition:endPosition:parentContexts:resultExpression:)<\/Name><USR>s:3PwZ17MemoizationRecordC13startPosition03endE014parentContexts16resultExpressionACSi_SiSayAA11ContextCaseOGAA0J0CSgtcfc<\/USR><Declaration>public init(startPosition: Position, endPosition: Position, parentContexts: [ContextCase], resultExpression: Expression?)<\/Declaration><CommentParts><Abstract><Para>Initializes a new <codeVoice>MemoizationRecord<\/codeVoice> from the necessary components.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 142,
            "key.doc.name" : "init(startPosition:endPosition:parentContexts:resultExpression:)",
            "key.doc.type" : "Function",
            "key.doclength" : 73,
            "key.docoffset" : 5623,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.constructor><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>init<\/syntaxtype.keyword>(<decl.var.parameter><decl.var.parameter.argument_label>startPosition<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>endPosition<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.typealias usr=\"s:3PwZ8Positiona\">Position<\/ref.typealias><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>parentContexts<\/decl.var.parameter.argument_label>: <decl.var.parameter.type>[<ref.enum usr=\"s:3PwZ11ContextCaseO\">ContextCase<\/ref.enum>]<\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>resultExpression<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ10ExpressionC\">Expression<\/ref.class>?<\/decl.var.parameter.type><\/decl.var.parameter>)<\/decl.function.constructor>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 299,
            "key.name" : "init(startPosition:endPosition:parentContexts:resultExpression:)",
            "key.namelength" : 114,
            "key.nameoffset" : 5707,
            "key.offset" : 5707,
            "key.parsed_declaration" : "public init(startPosition: Position, endPosition: Position, parentContexts: [ContextCase], resultExpression: Expression?)",
            "key.parsed_scope.end" : 147,
            "key.parsed_scope.start" : 142,
            "key.substructure" : [

            ],
            "key.typename" : "(MemoizationRecord.Type) -> (Int, Int, [ContextCase], Expression?) -> MemoizationRecord",
            "key.typeusr" : "$s13startPosition03endB014parentContexts16resultExpression3PwZ17MemoizationRecordCSi_SiSayAE11ContextCaseOGAE0G0CSgtcD",
            "key.usr" : "s:3PwZ17MemoizationRecordC13startPosition03endE014parentContexts16resultExpressionACSi_SiSayAA11ContextCaseOGAA0J0CSgtcfc"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public static func == (lhs: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>, rhs: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>) -&gt; <Type usr=\"s:Sb\">Bool<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 6090
              }
            ],
            "key.bodylength" : 229,
            "key.bodyoffset" : 6170,
            "key.doc.column" : 24,
            "key.doc.comment" : "`MemoizationRecords` are trivially `Equatable` from their components.",
            "key.doc.declaration" : "public static func == (lhs: MemoizationRecord, rhs: MemoizationRecord) -> Bool",
            "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"150\" column=\"24\"><Name>==(_:_:)<\/Name><USR>s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ<\/USR><Declaration>public static func == (lhs: MemoizationRecord, rhs: MemoizationRecord) -&gt; Bool<\/Declaration><CommentParts><Abstract><Para><codeVoice>MemoizationRecords<\/codeVoice> are trivially <codeVoice>Equatable<\/codeVoice> from their components.<\/Para><\/Abstract><\/CommentParts><\/Function>",
            "key.doc.line" : 150,
            "key.doc.name" : "==(_:_:)",
            "key.doc.type" : "Function",
            "key.doclength" : 74,
            "key.docoffset" : 6012,
            "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
            "key.fully_annotated_decl" : "<decl.function.operator.infix><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>static<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>== <\/decl.name>(<decl.var.parameter><decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.name>rhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>) -&gt; <decl.function.returntype><ref.struct usr=\"s:Sb\">Bool<\/ref.struct><\/decl.function.returntype><\/decl.function.operator.infix>",
            "key.kind" : "source.lang.swift.decl.function.method.static",
            "key.length" : 303,
            "key.name" : "==(_:_:)",
            "key.namelength" : 51,
            "key.nameoffset" : 6109,
            "key.offset" : 6097,
            "key.overrides" : [
              {
                "key.usr" : "s:SQ2eeoiySbx_xtFZ"
              }
            ],
            "key.parsed_declaration" : "public static func == (lhs: MemoizationRecord, rhs: MemoizationRecord) -> Bool",
            "key.parsed_scope.end" : 156,
            "key.parsed_scope.start" : 150,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ReferenceArrayC2eeoiySbACyxG_AEtFZ\">== (_: ReferenceArray&lt;Element&gt;, _: ReferenceArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ10ExpressionC2eeoiySbAC_ACtFZ\">== (_: Expression, _: Expression) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ14ExpressionCaseO2eeoiySbAC_ACtFZ\">== (_: ExpressionCase, _: ExpressionCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:3PwZ11ContextCaseO2eeoiySbAC_ACtFZ\">== (_: ContextCase, _: ContextCase) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbypXpSg_ABtF\">== (_: Any.Type?, _: Any.Type?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_xtSYRzSQ8RawValueRpzlF\">== &lt;T&gt;(_: T, _: T) -&gt; Bool where T : RawRepresentable, T.RawValue : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbyt_yttF\">== (_: (), _: ()) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_t_x_q_ttSQRzSQR_r0_lF\">== &lt;A, B&gt;(_: (A, B), _: (A, B)) -&gt; Bool where A : Equatable, B : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_t_x_q_q0_ttSQRzSQR_SQR0_r1_lF\">== &lt;A, B, C&gt;(_: (A, B, C), _: (A, B, C)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_t_x_q_q0_q1_ttSQRzSQR_SQR0_SQR1_r2_lF\">== &lt;A, B, C, D&gt;(_: (A, B, C, D), _: (A, B, C, D)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_t_x_q_q0_q1_q2_ttSQRzSQR_SQR0_SQR1_SQR2_r3_lF\">== &lt;A, B, C, D, E&gt;(_: (A, B, C, D, E), _: (A, B, C, D, E)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s2eeoiySbx_q_q0_q1_q2_q3_t_x_q_q0_q1_q2_q3_ttSQRzSQR_SQR0_SQR1_SQR2_SQR3_r4_lF\">== &lt;A, B, C, D, E, F&gt;(_: (A, B, C, D, E, F), _: (A, B, C, D, E, F)) -&gt; Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SasSQRzlE2eeoiySbSayxG_ABtFZ\">== (_: Array&lt;Element&gt;, _: Array&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10ArraySliceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ArraySlice&lt;Element&gt;, _: ArraySlice&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sb2eeoiyS2b_SbtFZ\">== (_: Bool, _: Bool) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SJ2eeoiySbSJ_SJtFZ\">== (_: Character, _: Character) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17CodingUserInfoKeyV2eeoiySbAB_ABtFZ\">== (_: CodingUserInfoKey, _: CodingUserInfoKey) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15ContiguousArrayVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: ContiguousArray&lt;Element&gt;, _: ContiguousArray&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SNsSxRzSZ6StrideRpzrlE5IndexO2eeoiySbADyx_G_AFtFZ\">== (_: ClosedRange&lt;Bound&gt;.Index, _: ClosedRange&lt;Bound&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SN2eeoiySbSNyxG_ABtFZ\">== (_: ClosedRange&lt;Bound&gt;, _: ClosedRange&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s13OpaquePointerV2eeoiySbAB_ABtFZ\">== (_: OpaquePointer, _: OpaquePointer) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD4KeysV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Keys, _: Dictionary&lt;Key, Value&gt;.Keys) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SDsSQR_rlE2eeoiySbSDyxq_G_ABtFZ\">== (_: [Key : Value], _: [Key : Value]) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SD5IndexV2eeoiySbAByxq__G_ADtFZ\">== (_: Dictionary&lt;Key, Value&gt;.Index, _: Dictionary&lt;Key, Value&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15EmptyCollectionV2eeoiySbAByxG_ADtFZ\">== (_: EmptyCollection&lt;Element&gt;, _: EmptyCollection&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SQ2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s15FlattenSequenceVsSlRzSl7ElementRpzrlE5IndexV2eeoiySbAFyx_G_AHtFZ\">== (_: FlattenCollection&lt;Base&gt;.Index, _: FlattenCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s17FloatingPointSignO2eeoiySbAB_ABtFZ\">== (_: FloatingPointSign, _: FloatingPointSign) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s27FloatingPointClassificationO2eeoiySbAB_ABtFZ\">== (_: FloatingPointClassification, _: FloatingPointClassification) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s25FloatingPointRoundingRuleO2eeoiySbAB_ABtFZ\">== (_: FloatingPointRoundingRule, _: FloatingPointRoundingRule) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SFsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11AnyHashableV2eeoiySbAB_ABtFZ\">== (_: AnyHashable, _: AnyHashable) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SzsE2eeoiySbx_qd__tSzRd__lFZ\">== &lt;Other&gt;(_: Self, _: Other) -&gt; Bool where Other : BinaryInteger<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5UInt8V2eeoiySbAB_ABtFZ\">== (_: UInt8, _: UInt8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4Int8V2eeoiySbAB_ABtFZ\">== (_: Int8, _: Int8) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt16V2eeoiySbAB_ABtFZ\">== (_: UInt16, _: UInt16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int16V2eeoiySbAB_ABtFZ\">== (_: Int16, _: Int16) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt32V2eeoiySbAB_ABtFZ\">== (_: UInt32, _: UInt32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int32V2eeoiySbAB_ABtFZ\">== (_: Int32, _: Int32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6UInt64V2eeoiySbAB_ABtFZ\">== (_: UInt64, _: UInt64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5Int64V2eeoiySbAB_ABtFZ\">== (_: Int64, _: Int64) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Su2eeoiySbSu_SutFZ\">== (_: UInt, _: UInt) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Si2eeoiySbSi_SitFZ\">== (_: Int, _: Int) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s10AnyKeyPathC2eeoiySbAB_ABtFZ\">== (_: AnyKeyPath, _: AnyKeyPath) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20ManagedBufferPointerV2eeoiySbAByxq_G_ADtFZ\">== (_: ManagedBufferPointer&lt;Header, Element&gt;, _: ManagedBufferPointer&lt;Header, Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO6ScalarV2eeoiySbAD_ADtFZ\">== (_: Unicode.Scalar, _: Unicode.Scalar) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SO2eeoiySbSO_SOtFZ\">== (_: ObjectIdentifier, _: ObjectIdentifier) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SqsSQRzlE2eeoiySbxSg_ABtFZ\">== (_: Wrapped?, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbxSg_s26_OptionalNilComparisonTypeVtFZ\">== (_: Wrapped?, _: _OptionalNilComparisonType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sq2eeoiySbs26_OptionalNilComparisonTypeV_xSgtFZ\">== (_: _OptionalNilComparisonType, _: Wrapped?) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8_PointerPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s5NeverO2eeoiySbAB_ABtFZ\">== (_: Never, _: Never) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s23LazyPrefixWhileSequenceVsSlRzrlE5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: LazyPrefixWhileCollection&lt;Base&gt;.Index, _: LazyPrefixWhileCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sn2eeoiySbSnyxG_ABtFZ\">== (_: Range&lt;Bound&gt;, _: Range&lt;Bound&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6ResultOsSQRzSQR_rlE2eeoiySbAByxq_G_ADtFZ\">== (_: Result&lt;Success, Failure&gt;, _: Result&lt;Success, Failure&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s18ReversedCollectionV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: ReversedCollection&lt;Base&gt;.Index, _: ReversedCollection&lt;Base&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh2eeoiySbShyxG_ABtFZ\">== (_: Set&lt;Element&gt;, _: Set&lt;Element&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sh5IndexV2eeoiySbAByx_G_ADtFZ\">== (_: Set&lt;Element&gt;.Index, _: Set&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SxsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SysE2eeoiySbx_qd__tSyRd__lFZ\">== &lt;RHS&gt;(_: Self, _: RHS) -&gt; Bool where RHS : StringProtocol<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS2eeoiySbSS_SStFZ\">== (_: String, _: String) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:SS5IndexV2eeoiySbAB_ABtFZ\">== (_: String.Index, _: String.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s11_UIntBufferV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: _UIntBuffer&lt;Element&gt;.Index, _: _UIntBuffer&lt;Element&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO15GeneralCategoryO2eeoiySbAD_ADtFZ\">== (_: Unicode.GeneralCategory, _: Unicode.GeneralCategory) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO23CanonicalCombiningClassV2eeoiySbAD_ADtFZ\">== (_: Unicode.CanonicalCombiningClass, _: Unicode.CanonicalCombiningClass) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO11NumericTypeO2eeoiySbAD_ADtFZ\">== (_: Unicode.NumericType, _: Unicode.NumericType) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s7UnicodeO5UTF32O2eeoiySbAD_ADtFZ\">== (_: Unicode.UTF32, _: Unicode.UTF32) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s21UnicodeDecodingResultO2eeoiySbAB_ABtFZ\">== (_: UnicodeDecodingResult, _: UnicodeDecodingResult) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s16_ValidUTF8BufferV5IndexV2eeoiySbAD_ADtFZ\">== (_: _ValidUTF8Buffer.Index, _: _ValidUTF8Buffer.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV5IndexV2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Index, _: CollectionDifference&lt;ChangeElement&gt;.Index) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceV6ChangeOsSQRzlE2eeoiySbADyx_G_AFtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;.Change, _: CollectionDifference&lt;ChangeElement&gt;.Change) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s20CollectionDifferenceVsSQRzlE2eeoiySbAByxG_ADtFZ\">== (_: CollectionDifference&lt;ChangeElement&gt;, _: CollectionDifference&lt;ChangeElement&gt;) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s8AnyIndexV2eeoiySbAB_ABtFZ\">== (_: AnyIndex, _: AnyIndex) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s6MirrorV12DisplayStyleO2eeoiySbAD_ADtFZ\">== (_: Mirror.DisplayStyle, _: Mirror.DisplayStyle) -&gt; Bool<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:s4SIMDPsE2eeoiySbx_xtFZ\">== (_: Self, _: Self) -&gt; Bool<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>let lhs: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type><\/Declaration>",
                "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
                "key.fully_annotated_decl" : "<decl.var.parameter><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.var.parameter.name>lhs<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>",
                "key.kind" : "source.lang.swift.decl.var.parameter",
                "key.length" : 3,
                "key.name" : "lhs",
                "key.offset" : 6113,
                "key.parent_loc" : 6109,
                "key.parsed_declaration" : "public static func == (lhs",
                "key.parsed_scope.end" : 150,
                "key.parsed_scope.start" : 150,
                "key.typename" : "MemoizationRecord",
                "key.typeusr" : "$s3PwZ17MemoizationRecordCD",
                "key.usr" : "s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ3lhsL_ACvp"
              }
            ],
            "key.typename" : "(MemoizationRecord.Type) -> (MemoizationRecord, MemoizationRecord) -> Bool",
            "key.typeusr" : "$sySb3PwZ17MemoizationRecordC_ACtcD",
            "key.usr" : "s:3PwZ17MemoizationRecordC2eeoiySbAC_ACtFZ"
          }
        ],
        "key.typename" : "MemoizationRecord.Type",
        "key.typeusr" : "$s3PwZ17MemoizationRecordCmD",
        "key.usr" : "s:3PwZ17MemoizationRecordC"
      },
      {
        "key.accessibility" : "source.lang.swift.accessibility.public",
        "key.annotated_decl" : "<Declaration>public typealias Zipper = (expression: <Type usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/Type>, context: <Type usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/Type>)<\/Declaration>",
        "key.attributes" : [
          {
            "key.attribute" : "source.decl.attribute.public",
            "key.length" : 6,
            "key.offset" : 6704
          }
        ],
        "key.doc.column" : 18,
        "key.doc.comment" : "A Zipper is a pair of an expression with its parent context, allowing for\nefficient traversal of tree-like objects. We have adjusted the traditional\nzipper to support alternates (representing non-determinisim) as well as cycles.",
        "key.doc.declaration" : "public typealias Zipper = (expression: ExpressionCase, context: MemoizationRecord)",
        "key.doc.file" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.doc.full_as_xml" : "<Other file=\"\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift\" line=\"170\" column=\"18\"><Name>Zipper<\/Name><USR>s:3PwZ6Zippera<\/USR><Declaration>public typealias Zipper = (expression: ExpressionCase, context: MemoizationRecord)<\/Declaration><CommentParts><Abstract><Para>A Zipper is a pair of an expression with its parent context, allowing for efficient traversal of tree-like objects. We have adjusted the traditional zipper to support alternates (representing non-determinisim) as well as cycles.<\/Para><\/Abstract><\/CommentParts><\/Other>",
        "key.doc.line" : 170,
        "key.doc.name" : "Zipper",
        "key.doc.type" : "Other",
        "key.doclength" : 239,
        "key.docoffset" : 6464,
        "key.filepath" : "\/Users\/pdarragh\/Development\/swift-parsing-with-zippers\/Sources\/PwZ\/Types.swift",
        "key.fully_annotated_decl" : "<decl.typealias><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>typealias<\/syntaxtype.keyword> <decl.name>Zipper<\/decl.name> = <tuple>(<tuple.element><tuple.element.argument_label>expression<\/tuple.element.argument_label>: <tuple.element.type><ref.enum usr=\"s:3PwZ14ExpressionCaseO\">ExpressionCase<\/ref.enum><\/tuple.element.type><\/tuple.element>, <tuple.element><tuple.element.argument_label>context<\/tuple.element.argument_label>: <tuple.element.type><ref.class usr=\"s:3PwZ17MemoizationRecordC\">MemoizationRecord<\/ref.class><\/tuple.element.type><\/tuple.element>)<\/tuple><\/decl.typealias>",
        "key.kind" : "source.lang.swift.decl.typealias",
        "key.length" : 75,
        "key.name" : "Zipper",
        "key.namelength" : 6,
        "key.nameoffset" : 6721,
        "key.offset" : 6711,
        "key.parsed_declaration" : "public typealias Zipper = (expression: ExpressionCase, context: MemoizationRecord)",
        "key.parsed_scope.end" : 170,
        "key.parsed_scope.start" : 170,
        "key.typename" : "(expression: ExpressionCase, context: MemoizationRecord).Type",
        "key.typeusr" : "$s3PwZ14ExpressionCaseO10expression_AA17MemoizationRecordC7contexttmD",
        "key.usr" : "s:3PwZ6Zippera"
      }
    ]
  }
}]
